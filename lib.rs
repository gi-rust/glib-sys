// This file was generated by grust-gen 0.1.3

#![crate_name = "glib_2_0_sys"]
#![crate_type = "lib"]
#![allow(non_upper_case_globals)]  // For G_CSET_a_2_z

extern crate gtypes;
extern crate libc;

use gtypes::*;


#[repr(C)]
pub struct GDate([u32; 2]);

#[repr(C)]
pub struct GDoubleIEEE754(gdouble);

#[repr(C)]
pub struct GFloatIEEE754(gfloat);

#[repr(C)]
pub struct GHookList {
    pub seq_id: gulong,
    // Two bit fields in the C definition here
    _hook_size_is_setup: u32,
    pub hooks: *mut GHook,
    dummy3: gpointer,
    pub finalize_hook: Option<GHookFinalizeFunc>,
    dummy: [gpointer; 2]
}

#[repr(C)]
pub struct GIOChannel {
    ref_count :gint,
    funcs: *mut GIOFuncs,

    encoding: *mut gchar,
    read_cd: GIConv,
    write_cd: GIConv,
    line_term: *mut gchar,
    line_term_len: gint,

    buf_size: gsize,
    read_buf: *mut GString,
    encoded_read_buf: *mut GString,
    write_buf: *mut GString,


    partial_write_buf: [gchar; 6],

    // A group of bit fields in the C definition here
    // to fit after partial_write_buf
    flags: u16,

    reserved1: gpointer,
    reserved2: gpointer
}

// This happens to get the same determinants in all Unixes I have surveyed,
// and for non-Unix GLib provides the same values.
#[repr(C)]
pub enum GIOCondition {
    In   =  1,
    Out  =  4,
    Pri  =  2,
    Err  =  8,
    Hup  = 16,
    Nval = 32
}
pub const G_IO_IN:   guint = GIOCondition::In as guint;
pub const G_IO_OUT:  guint = GIOCondition::Out as guint;
pub const G_IO_PRI:  guint = GIOCondition::Pri as guint;
pub const G_IO_ERR:  guint = GIOCondition::Err as guint;
pub const G_IO_HUP:  guint = GIOCondition::Hup as guint;
pub const G_IO_NVAL: guint = GIOCondition::Nval as guint;

#[cfg(target_pointer_width = "32")]
#[repr(C)]
pub struct GMutex([guint; 2]);

// NOTE: An ILP64 target would need GMutex defined as above
#[cfg(target_pointer_width = "64")]
#[repr(C)]
pub struct GMutex(gpointer);

#[cfg(unix)]
pub type GPid = gint;

#[cfg(windows)]
pub type GPid = *mut libc::c_void;

#[repr(C)]
pub struct  GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,

    // a group of bit fields in the C definition here
    flags: u32,

    padding_dummy: guint
}

#[repr(C)]
pub struct GTokenValue {
    v: u64
}


pub type GDateDay = u8;

pub type GDateYear = u16;

pub type GMutexLocker = gpointer;

pub type GQuark = u32;

pub type GStrv = gpointer;

pub type GTime = i32;

pub type GTimeSpan = i64;

pub const G_ANALYZER_ANALYZING: gint = 1;

pub const G_ASCII_DTOSTR_BUF_SIZE: gint = 39;

#[repr(C)]
pub struct GArray {
    pub data: *mut gchar,
    pub len: guint,
}

#[repr(C)]
pub enum GAsciiType {
    Alnum = 1,
    Alpha = 2,
    Cntrl = 4,
    Digit = 8,
    Graph = 16,
    Lower = 32,
    Print = 64,
    Punct = 128,
    Space = 256,
    Upper = 512,
    Xdigit = 1024,
}
pub const G_ASCII_ALNUM: guint = 1;
pub const G_ASCII_ALPHA: guint = 2;
pub const G_ASCII_CNTRL: guint = 4;
pub const G_ASCII_DIGIT: guint = 8;
pub const G_ASCII_GRAPH: guint = 16;
pub const G_ASCII_LOWER: guint = 32;
pub const G_ASCII_PRINT: guint = 64;
pub const G_ASCII_PUNCT: guint = 128;
pub const G_ASCII_SPACE: guint = 256;
pub const G_ASCII_UPPER: guint = 512;
pub const G_ASCII_XDIGIT: guint = 1024;

#[repr(C)]
pub struct GAsyncQueue(gpointer);

pub const G_BIG_ENDIAN: gint = 4321;

#[repr(C)]
pub struct GBookmarkFile(gpointer);

#[repr(C)]
pub enum GBookmarkFileError {
    InvalidUri = 0,
    InvalidValue = 1,
    AppNotRegistered = 2,
    UriNotFound = 3,
    Read = 4,
    UnknownEncoding = 5,
    Write = 6,
    FileNotFound = 7,
}
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = GBookmarkFileError::InvalidUri;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = GBookmarkFileError::InvalidValue;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = GBookmarkFileError::AppNotRegistered;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = GBookmarkFileError::UriNotFound;
pub const G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = GBookmarkFileError::Read;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = GBookmarkFileError::UnknownEncoding;
pub const G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = GBookmarkFileError::Write;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = GBookmarkFileError::FileNotFound;

#[repr(C)]
pub struct GByteArray {
    pub data: u8,
    pub len: guint,
}

pub enum GBytes { }

pub const G_CSET_A_2_Z: &'static [u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";

pub const G_CSET_DIGITS: &'static [u8] = b"0123456789\0";

pub const G_CSET_a_2_z: &'static [u8] = b"abcdefghijklmnopqrstuvwxyz\0";

pub enum GChecksum { }

#[repr(C)]
pub enum GChecksumType {
    Md5 = 0,
    Sha1 = 1,
    Sha256 = 2,
    Sha512 = 3,
}
pub const G_CHECKSUM_MD5: GChecksumType = GChecksumType::Md5;
pub const G_CHECKSUM_SHA1: GChecksumType = GChecksumType::Sha1;
pub const G_CHECKSUM_SHA256: GChecksumType = GChecksumType::Sha256;
pub const G_CHECKSUM_SHA512: GChecksumType = GChecksumType::Sha512;

pub type GChildWatchFunc = extern "C" fn (GPid, gint, gpointer);

pub type GCompareDataFunc = extern "C" fn (gconstpointer, gconstpointer, gpointer) -> gint;

pub type GCompareFunc = extern "C" fn (gconstpointer, gconstpointer) -> gint;

#[repr(C)]
pub struct GCond {
    p: gpointer,
    i: [guint; 2],
}

#[repr(C)]
pub enum GConvertError {
    NoConversion = 0,
    IllegalSequence = 1,
    Failed = 2,
    PartialInput = 3,
    BadUri = 4,
    NotAbsolutePath = 5,
    NoMemory = 6,
}
pub const G_CONVERT_ERROR_NO_CONVERSION: GConvertError = GConvertError::NoConversion;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = GConvertError::IllegalSequence;
pub const G_CONVERT_ERROR_FAILED: GConvertError = GConvertError::Failed;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = GConvertError::PartialInput;
pub const G_CONVERT_ERROR_BAD_URI: GConvertError = GConvertError::BadUri;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = GConvertError::NotAbsolutePath;
pub const G_CONVERT_ERROR_NO_MEMORY: GConvertError = GConvertError::NoMemory;

pub type GCopyFunc = extern "C" fn (gconstpointer, gpointer) -> gpointer;

pub const G_DATALIST_FLAGS_MASK: gint = 3;

pub const G_DATE_BAD_DAY: gint = 0;

pub const G_DATE_BAD_JULIAN: gint = 0;

pub const G_DATE_BAD_YEAR: gint = 0;

#[repr(C)]
pub struct GData(gpointer);

pub type GDataForeachFunc = extern "C" fn (GQuark, gpointer, gpointer);

#[repr(C)]
pub enum GDateDMY {
    Day = 0,
    Month = 1,
    Year = 2,
}
pub const G_DATE_DAY: GDateDMY = GDateDMY::Day;
pub const G_DATE_MONTH: GDateDMY = GDateDMY::Month;
pub const G_DATE_YEAR: GDateDMY = GDateDMY::Year;

#[repr(C)]
pub enum GDateMonth {
    BadMonth = 0,
    January = 1,
    February = 2,
    March = 3,
    April = 4,
    May = 5,
    June = 6,
    July = 7,
    August = 8,
    September = 9,
    October = 10,
    November = 11,
    December = 12,
}
pub const G_DATE_BAD_MONTH: GDateMonth = GDateMonth::BadMonth;
pub const G_DATE_JANUARY: GDateMonth = GDateMonth::January;
pub const G_DATE_FEBRUARY: GDateMonth = GDateMonth::February;
pub const G_DATE_MARCH: GDateMonth = GDateMonth::March;
pub const G_DATE_APRIL: GDateMonth = GDateMonth::April;
pub const G_DATE_MAY: GDateMonth = GDateMonth::May;
pub const G_DATE_JUNE: GDateMonth = GDateMonth::June;
pub const G_DATE_JULY: GDateMonth = GDateMonth::July;
pub const G_DATE_AUGUST: GDateMonth = GDateMonth::August;
pub const G_DATE_SEPTEMBER: GDateMonth = GDateMonth::September;
pub const G_DATE_OCTOBER: GDateMonth = GDateMonth::October;
pub const G_DATE_NOVEMBER: GDateMonth = GDateMonth::November;
pub const G_DATE_DECEMBER: GDateMonth = GDateMonth::December;

pub enum GDateTime { }

#[repr(C)]
pub enum GDateWeekday {
    BadWeekday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
    Sunday = 7,
}
pub const G_DATE_BAD_WEEKDAY: GDateWeekday = GDateWeekday::BadWeekday;
pub const G_DATE_MONDAY: GDateWeekday = GDateWeekday::Monday;
pub const G_DATE_TUESDAY: GDateWeekday = GDateWeekday::Tuesday;
pub const G_DATE_WEDNESDAY: GDateWeekday = GDateWeekday::Wednesday;
pub const G_DATE_THURSDAY: GDateWeekday = GDateWeekday::Thursday;
pub const G_DATE_FRIDAY: GDateWeekday = GDateWeekday::Friday;
pub const G_DATE_SATURDAY: GDateWeekday = GDateWeekday::Saturday;
pub const G_DATE_SUNDAY: GDateWeekday = GDateWeekday::Sunday;

#[repr(C)]
pub struct GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}

pub type GDestroyNotify = extern "C" fn (gpointer);

#[repr(C)]
pub struct GDir(gpointer);

pub type GDuplicateFunc = extern "C" fn (gpointer, gpointer) -> gpointer;

pub const G_E: gdouble = 2.718282;

pub type GEqualFunc = extern "C" fn (gconstpointer, gconstpointer) -> gboolean;

#[repr(C)]
pub struct GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}

#[repr(C)]
pub enum GErrorType {
    Unknown = 0,
    UnexpEof = 1,
    UnexpEofInString = 2,
    UnexpEofInComment = 3,
    NonDigitInConst = 4,
    DigitRadix = 5,
    FloatRadix = 6,
    FloatMalformed = 7,
}
pub const G_ERR_UNKNOWN: GErrorType = GErrorType::Unknown;
pub const G_ERR_UNEXP_EOF: GErrorType = GErrorType::UnexpEof;
pub const G_ERR_UNEXP_EOF_IN_STRING: GErrorType = GErrorType::UnexpEofInString;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = GErrorType::UnexpEofInComment;
pub const G_ERR_NON_DIGIT_IN_CONST: GErrorType = GErrorType::NonDigitInConst;
pub const G_ERR_DIGIT_RADIX: GErrorType = GErrorType::DigitRadix;
pub const G_ERR_FLOAT_RADIX: GErrorType = GErrorType::FloatRadix;
pub const G_ERR_FLOAT_MALFORMED: GErrorType = GErrorType::FloatMalformed;

#[repr(C)]
pub enum GFileError {
    Exist = 0,
    Isdir = 1,
    Acces = 2,
    Nametoolong = 3,
    Noent = 4,
    Notdir = 5,
    Nxio = 6,
    Nodev = 7,
    Rofs = 8,
    Txtbsy = 9,
    Fault = 10,
    Loop = 11,
    Nospc = 12,
    Nomem = 13,
    Mfile = 14,
    Nfile = 15,
    Badf = 16,
    Inval = 17,
    Pipe = 18,
    Again = 19,
    Intr = 20,
    Io = 21,
    Perm = 22,
    Nosys = 23,
    Failed = 24,
}
pub const G_FILE_ERROR_EXIST: GFileError = GFileError::Exist;
pub const G_FILE_ERROR_ISDIR: GFileError = GFileError::Isdir;
pub const G_FILE_ERROR_ACCES: GFileError = GFileError::Acces;
pub const G_FILE_ERROR_NAMETOOLONG: GFileError = GFileError::Nametoolong;
pub const G_FILE_ERROR_NOENT: GFileError = GFileError::Noent;
pub const G_FILE_ERROR_NOTDIR: GFileError = GFileError::Notdir;
pub const G_FILE_ERROR_NXIO: GFileError = GFileError::Nxio;
pub const G_FILE_ERROR_NODEV: GFileError = GFileError::Nodev;
pub const G_FILE_ERROR_ROFS: GFileError = GFileError::Rofs;
pub const G_FILE_ERROR_TXTBSY: GFileError = GFileError::Txtbsy;
pub const G_FILE_ERROR_FAULT: GFileError = GFileError::Fault;
pub const G_FILE_ERROR_LOOP: GFileError = GFileError::Loop;
pub const G_FILE_ERROR_NOSPC: GFileError = GFileError::Nospc;
pub const G_FILE_ERROR_NOMEM: GFileError = GFileError::Nomem;
pub const G_FILE_ERROR_MFILE: GFileError = GFileError::Mfile;
pub const G_FILE_ERROR_NFILE: GFileError = GFileError::Nfile;
pub const G_FILE_ERROR_BADF: GFileError = GFileError::Badf;
pub const G_FILE_ERROR_INVAL: GFileError = GFileError::Inval;
pub const G_FILE_ERROR_PIPE: GFileError = GFileError::Pipe;
pub const G_FILE_ERROR_AGAIN: GFileError = GFileError::Again;
pub const G_FILE_ERROR_INTR: GFileError = GFileError::Intr;
pub const G_FILE_ERROR_IO: GFileError = GFileError::Io;
pub const G_FILE_ERROR_PERM: GFileError = GFileError::Perm;
pub const G_FILE_ERROR_NOSYS: GFileError = GFileError::Nosys;
pub const G_FILE_ERROR_FAILED: GFileError = GFileError::Failed;

#[repr(C)]
pub enum GFileTest {
    IsRegular = 1,
    IsSymlink = 2,
    IsDir = 4,
    IsExecutable = 8,
    Exists = 16,
}
pub const G_FILE_TEST_IS_REGULAR: guint = 1;
pub const G_FILE_TEST_IS_SYMLINK: guint = 2;
pub const G_FILE_TEST_IS_DIR: guint = 4;
pub const G_FILE_TEST_IS_EXECUTABLE: guint = 8;
pub const G_FILE_TEST_EXISTS: guint = 16;

#[repr(C)]
pub enum GFormatSizeFlags {
    Default = 0,
    LongFormat = 1,
    IecUnits = 2,
}
pub const G_FORMAT_SIZE_DEFAULT: guint = 0;
pub const G_FORMAT_SIZE_LONG_FORMAT: guint = 1;
pub const G_FORMAT_SIZE_IEC_UNITS: guint = 2;

pub type GFreeFunc = extern "C" fn (gpointer);

pub type GFunc = extern "C" fn (gpointer, gpointer);

pub const G_GNUC_FUNCTION: &'static [u8] = b"\0";

pub const G_GNUC_PRETTY_FUNCTION: &'static [u8] = b"\0";

pub type GHFunc = extern "C" fn (gpointer, gpointer, gpointer);

pub const G_HOOK_FLAG_USER_SHIFT: gint = 4;

pub type GHRFunc = extern "C" fn (gpointer, gpointer, gpointer) -> gboolean;

pub type GHashFunc = extern "C" fn (gconstpointer) -> guint;

pub enum GHashTable { }

#[repr(C)]
pub struct GHashTableIter {
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: gpointer,
    dummy4: gint,
    dummy5: gboolean,
    dummy6: gpointer,
}

#[repr(C)]
pub struct GHmac(gpointer);

#[repr(C)]
pub struct GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: Option<GDestroyNotify>,
}

pub type GHookCheckFunc = extern "C" fn (gpointer) -> gboolean;

pub type GHookCheckMarshaller = extern "C" fn (*mut GHook, gpointer) -> gboolean;

pub type GHookCompareFunc = extern "C" fn (*mut GHook, *mut GHook) -> gint;

pub type GHookFinalizeFunc = extern "C" fn (*mut GHookList, *mut GHook);

pub type GHookFindFunc = extern "C" fn (*mut GHook, gpointer) -> gboolean;

#[repr(C)]
pub enum GHookFlagMask {
    Active = 1,
    InCall = 2,
    Mask = 15,
}
pub const G_HOOK_FLAG_ACTIVE: guint = 1;
pub const G_HOOK_FLAG_IN_CALL: guint = 2;
pub const G_HOOK_FLAG_MASK: guint = 15;

pub type GHookFunc = extern "C" fn (gpointer);

pub type GHookMarshaller = extern "C" fn (*mut GHook, gpointer);

#[repr(C)]
pub struct GIConv(gpointer);

pub const G_IEEE754_DOUBLE_BIAS: gint = 1023;

pub const G_IEEE754_FLOAT_BIAS: gint = 127;

#[repr(C)]
pub enum GIOChannelError {
    Fbig = 0,
    Inval = 1,
    Io = 2,
    Isdir = 3,
    Nospc = 4,
    Nxio = 5,
    Overflow = 6,
    Pipe = 7,
    Failed = 8,
}
pub const G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = GIOChannelError::Fbig;
pub const G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = GIOChannelError::Inval;
pub const G_IO_CHANNEL_ERROR_IO: GIOChannelError = GIOChannelError::Io;
pub const G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = GIOChannelError::Isdir;
pub const G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = GIOChannelError::Nospc;
pub const G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = GIOChannelError::Nxio;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = GIOChannelError::Overflow;
pub const G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = GIOChannelError::Pipe;
pub const G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = GIOChannelError::Failed;

#[repr(C)]
pub enum GIOError {
    None = 0,
    Again = 1,
    Inval = 2,
    Unknown = 3,
}
pub const G_IO_ERROR_NONE: GIOError = GIOError::None;
pub const G_IO_ERROR_AGAIN: GIOError = GIOError::Again;
pub const G_IO_ERROR_INVAL: GIOError = GIOError::Inval;
pub const G_IO_ERROR_UNKNOWN: GIOError = GIOError::Unknown;

#[repr(C)]
pub enum GIOFlags {
    Append = 1,
    Nonblock = 2,
    SetMask = 3,
    IsReadable = 4,
    IsWritable = 8,
    IsSeekable = 16,
    Mask = 31,
}
pub const G_IO_FLAG_APPEND: guint = 1;
pub const G_IO_FLAG_NONBLOCK: guint = 2;
pub const G_IO_FLAG_IS_READABLE: guint = 4;
pub const G_IO_FLAG_IS_WRITABLE: guint = 8;
pub const G_IO_FLAG_IS_WRITEABLE: guint = 8;
pub const G_IO_FLAG_IS_SEEKABLE: guint = 16;
pub const G_IO_FLAG_MASK: guint = 31;
pub const G_IO_FLAG_GET_MASK: guint = 31;
pub const G_IO_FLAG_SET_MASK: guint = 3;

pub type GIOFunc = extern "C" fn (*mut GIOChannel, GIOCondition, gpointer) -> gboolean;

#[repr(C)]
pub struct GIOFuncs {
    pub io_read: Option<extern "C" fn (*mut GIOChannel, *mut gchar, gsize, gsize) -> GIOStatus>,
    pub io_write: Option<extern "C" fn (*mut GIOChannel, *const gchar, gsize, gsize) -> GIOStatus>,
    pub io_seek: Option<extern "C" fn (*mut GIOChannel, i64, GSeekType) -> GIOStatus>,
    pub io_close: Option<extern "C" fn (*mut GIOChannel) -> GIOStatus>,
    pub io_create_watch: Option<extern "C" fn (*mut GIOChannel, GIOCondition) -> *mut GSource>,
    pub io_free: Option<extern "C" fn (*mut GIOChannel)>,
    pub io_set_flags: Option<extern "C" fn (*mut GIOChannel, GIOFlags) -> GIOStatus>,
    pub io_get_flags: Option<extern "C" fn (*mut GIOChannel) -> GIOFlags>,
}

#[repr(C)]
pub enum GIOStatus {
    Error = 0,
    Normal = 1,
    Eof = 2,
    Again = 3,
}
pub const G_IO_STATUS_ERROR: GIOStatus = GIOStatus::Error;
pub const G_IO_STATUS_NORMAL: GIOStatus = GIOStatus::Normal;
pub const G_IO_STATUS_EOF: GIOStatus = GIOStatus::Eof;
pub const G_IO_STATUS_AGAIN: GIOStatus = GIOStatus::Again;

pub const G_KEY_FILE_DESKTOP_GROUP: &'static [u8] = b"Desktop Entry\0";

pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &'static [u8] = b"Actions\0";

pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &'static [u8] = b"Categories\0";

pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &'static [u8] = b"Comment\0";

pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &'static [u8] = b"DBusActivatable\0";

pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &'static [u8] = b"Exec\0";

pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &'static [u8] = b"GenericName\0";

pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &'static [u8] = b"Hidden\0";

pub const G_KEY_FILE_DESKTOP_KEY_ICON: &'static [u8] = b"Icon\0";

pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &'static [u8] = b"MimeType\0";

pub const G_KEY_FILE_DESKTOP_KEY_NAME: &'static [u8] = b"Name\0";

pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &'static [u8] = b"NotShowIn\0";

pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &'static [u8] = b"NoDisplay\0";

pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &'static [u8] = b"OnlyShowIn\0";

pub const G_KEY_FILE_DESKTOP_KEY_PATH: &'static [u8] = b"Path\0";

pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &'static [u8] = b"StartupNotify\0";

pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &'static [u8] = b"StartupWMClass\0";

pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &'static [u8] = b"Terminal\0";

pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &'static [u8] = b"TryExec\0";

pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &'static [u8] = b"Type\0";

pub const G_KEY_FILE_DESKTOP_KEY_URL: &'static [u8] = b"URL\0";

pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &'static [u8] = b"Version\0";

pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &'static [u8] = b"Application\0";

pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &'static [u8] = b"Directory\0";

pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &'static [u8] = b"Link\0";

pub enum GKeyFile { }

#[repr(C)]
pub enum GKeyFileError {
    UnknownEncoding = 0,
    Parse = 1,
    NotFound = 2,
    KeyNotFound = 3,
    GroupNotFound = 4,
    InvalidValue = 5,
}
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = GKeyFileError::UnknownEncoding;
pub const G_KEY_FILE_ERROR_PARSE: GKeyFileError = GKeyFileError::Parse;
pub const G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = GKeyFileError::NotFound;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = GKeyFileError::KeyNotFound;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = GKeyFileError::GroupNotFound;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = GKeyFileError::InvalidValue;

#[repr(C)]
pub enum GKeyFileFlags {
    None = 0,
    KeepComments = 1,
    KeepTranslations = 2,
}
pub const G_KEY_FILE_NONE: guint = 0;
pub const G_KEY_FILE_KEEP_COMMENTS: guint = 1;
pub const G_KEY_FILE_KEEP_TRANSLATIONS: guint = 2;

pub const G_LITTLE_ENDIAN: gint = 1234;

pub const G_LN10: gdouble = 2.302585;

pub const G_LN2: gdouble = 0.693147;

pub const G_LOG_2_BASE_10: gdouble = 0.301030;

pub const G_LOG_DOMAIN: gchar = 0;

pub const G_LOG_FATAL_MASK: gint = 0;

pub const G_LOG_LEVEL_USER_SHIFT: gint = 8;

#[repr(C)]
pub struct GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}

pub type GLogFunc = extern "C" fn (*const gchar, GLogLevelFlags, *const gchar, gpointer);

#[repr(C)]
pub enum GLogLevelFlags {
    LevelMask = -4,
    FlagRecursion = 1,
    FlagFatal = 2,
    LevelError = 4,
    LevelCritical = 8,
    LevelWarning = 16,
    LevelMessage = 32,
    LevelInfo = 64,
    LevelDebug = 128,
}
pub const G_LOG_FLAG_RECURSION: guint = 1;
pub const G_LOG_FLAG_FATAL: guint = 2;
pub const G_LOG_LEVEL_ERROR: guint = 4;
pub const G_LOG_LEVEL_CRITICAL: guint = 8;
pub const G_LOG_LEVEL_WARNING: guint = 16;
pub const G_LOG_LEVEL_MESSAGE: guint = 32;
pub const G_LOG_LEVEL_INFO: guint = 64;
pub const G_LOG_LEVEL_DEBUG: guint = 128;
pub const G_LOG_LEVEL_MASK: guint = -4i64 as guint;

pub const GLIB_MAJOR_VERSION: gint = 2;

pub const G_MAXINT16: i16 = 32767;

pub const G_MAXINT32: i32 = 2147483647;

pub const G_MAXINT64: i64 = 9223372036854775807;

pub const G_MAXINT8: i8 = 127;

pub const G_MAXUINT16: u16 = 65535;

pub const G_MAXUINT32: u32 = 4294967295;

pub const G_MAXUINT64: u64 = 18446744073709551615;

pub const G_MAXUINT8: u8 = 255;

pub const GLIB_MICRO_VERSION: gint = 1;

pub const G_MININT16: i16 = -32768;

pub const G_MININT32: i32 = -2147483648;

pub const G_MININT64: i64 = -9223372036854775808;

pub const G_MININT8: i8 = -128;

pub const GLIB_MINOR_VERSION: gint = 47;

pub enum GMainContext { }

pub enum GMainLoop { }

pub enum GMappedFile { }

#[repr(C)]
pub enum GMarkupCollectType {
    Invalid = 0,
    String = 1,
    Strdup = 2,
    Boolean = 3,
    Tristate = 4,
    Optional = 65536,
}
pub const G_MARKUP_COLLECT_INVALID: guint = 0;
pub const G_MARKUP_COLLECT_STRING: guint = 1;
pub const G_MARKUP_COLLECT_STRDUP: guint = 2;
pub const G_MARKUP_COLLECT_BOOLEAN: guint = 3;
pub const G_MARKUP_COLLECT_TRISTATE: guint = 4;
pub const G_MARKUP_COLLECT_OPTIONAL: guint = 65536;

#[repr(C)]
pub enum GMarkupError {
    BadUtf8 = 0,
    Empty = 1,
    Parse = 2,
    UnknownElement = 3,
    UnknownAttribute = 4,
    InvalidContent = 5,
    MissingAttribute = 6,
}
pub const G_MARKUP_ERROR_BAD_UTF8: GMarkupError = GMarkupError::BadUtf8;
pub const G_MARKUP_ERROR_EMPTY: GMarkupError = GMarkupError::Empty;
pub const G_MARKUP_ERROR_PARSE: GMarkupError = GMarkupError::Parse;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = GMarkupError::UnknownElement;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = GMarkupError::UnknownAttribute;
pub const G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = GMarkupError::InvalidContent;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = GMarkupError::MissingAttribute;

pub enum GMarkupParseContext { }

#[repr(C)]
pub enum GMarkupParseFlags {
    DoNotUseThisUnsupportedFlag = 1,
    TreatCdataAsText = 2,
    PrefixErrorPosition = 4,
    IgnoreQualified = 8,
}
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: guint = 1;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT: guint = 2;
pub const G_MARKUP_PREFIX_ERROR_POSITION: guint = 4;
pub const G_MARKUP_IGNORE_QUALIFIED: guint = 8;

#[repr(C)]
pub struct GMarkupParser {
    pub start_element: Option<extern "C" fn (*mut GMarkupParseContext, *const gchar, *mut *const gchar, *mut *const gchar, gpointer)>,
    pub end_element: Option<extern "C" fn (*mut GMarkupParseContext, *const gchar, gpointer)>,
    pub text: Option<extern "C" fn (*mut GMarkupParseContext, *const gchar, gsize, gpointer)>,
    pub passthrough: Option<extern "C" fn (*mut GMarkupParseContext, *const gchar, gsize, gpointer)>,
    pub error: Option<extern "C" fn (*mut GMarkupParseContext, *mut GError, gpointer)>,
}

pub enum GMatchInfo { }

#[repr(C)]
pub struct GMemVTable {
    pub malloc: Option<extern "C" fn (gsize) -> gpointer>,
    pub realloc: Option<extern "C" fn (gpointer, gsize) -> gpointer>,
    pub free: Option<extern "C" fn (gpointer)>,
    pub calloc: Option<extern "C" fn (gsize, gsize) -> gpointer>,
    pub try_malloc: Option<extern "C" fn (gsize) -> gpointer>,
    pub try_realloc: Option<extern "C" fn (gpointer, gsize) -> gpointer>,
}

#[repr(C)]
pub struct GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}

pub type GNodeForeachFunc = extern "C" fn (*mut GNode, gpointer);

pub type GNodeTraverseFunc = extern "C" fn (*mut GNode, gpointer) -> gboolean;

#[repr(C)]
pub enum GNormalizeMode {
    Default = 0,
    DefaultCompose = 1,
    All = 2,
    AllCompose = 3,
}
pub const G_NORMALIZE_DEFAULT: GNormalizeMode = GNormalizeMode::Default;
pub const G_NORMALIZE_NFD: GNormalizeMode = GNormalizeMode::Default;
pub const G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = GNormalizeMode::DefaultCompose;
pub const G_NORMALIZE_NFC: GNormalizeMode = GNormalizeMode::DefaultCompose;
pub const G_NORMALIZE_ALL: GNormalizeMode = GNormalizeMode::All;
pub const G_NORMALIZE_NFKD: GNormalizeMode = GNormalizeMode::All;
pub const G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = GNormalizeMode::AllCompose;
pub const G_NORMALIZE_NFKC: GNormalizeMode = GNormalizeMode::AllCompose;

pub const G_OPTION_REMAINING: &'static [u8] = b"\0";

#[repr(C)]
pub struct GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}

#[repr(C)]
pub enum GOnceStatus {
    Notcalled = 0,
    Progress = 1,
    Ready = 2,
}
pub const G_ONCE_STATUS_NOTCALLED: GOnceStatus = GOnceStatus::Notcalled;
pub const G_ONCE_STATUS_PROGRESS: GOnceStatus = GOnceStatus::Progress;
pub const G_ONCE_STATUS_READY: GOnceStatus = GOnceStatus::Ready;

#[repr(C)]
pub enum GOptionArg {
    None = 0,
    String = 1,
    Int = 2,
    Callback = 3,
    Filename = 4,
    StringArray = 5,
    FilenameArray = 6,
    Double = 7,
    Int64 = 8,
}
pub const G_OPTION_ARG_NONE: GOptionArg = GOptionArg::None;
pub const G_OPTION_ARG_STRING: GOptionArg = GOptionArg::String;
pub const G_OPTION_ARG_INT: GOptionArg = GOptionArg::Int;
pub const G_OPTION_ARG_CALLBACK: GOptionArg = GOptionArg::Callback;
pub const G_OPTION_ARG_FILENAME: GOptionArg = GOptionArg::Filename;
pub const G_OPTION_ARG_STRING_ARRAY: GOptionArg = GOptionArg::StringArray;
pub const G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = GOptionArg::FilenameArray;
pub const G_OPTION_ARG_DOUBLE: GOptionArg = GOptionArg::Double;
pub const G_OPTION_ARG_INT64: GOptionArg = GOptionArg::Int64;

pub type GOptionArgFunc = extern "C" fn (*const gchar, *const gchar, gpointer) -> gboolean;

#[repr(C)]
pub struct GOptionContext(gpointer);

#[repr(C)]
pub struct GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}

#[repr(C)]
pub enum GOptionError {
    UnknownOption = 0,
    BadValue = 1,
    Failed = 2,
}
pub const G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = GOptionError::UnknownOption;
pub const G_OPTION_ERROR_BAD_VALUE: GOptionError = GOptionError::BadValue;
pub const G_OPTION_ERROR_FAILED: GOptionError = GOptionError::Failed;

pub type GOptionErrorFunc = extern "C" fn (*mut GOptionContext, *mut GOptionGroup, gpointer);

#[repr(C)]
pub enum GOptionFlags {
    None = 0,
    Hidden = 1,
    InMain = 2,
    Reverse = 4,
    NoArg = 8,
    Filename = 16,
    OptionalArg = 32,
    Noalias = 64,
}
pub const G_OPTION_FLAG_NONE: guint = 0;
pub const G_OPTION_FLAG_HIDDEN: guint = 1;
pub const G_OPTION_FLAG_IN_MAIN: guint = 2;
pub const G_OPTION_FLAG_REVERSE: guint = 4;
pub const G_OPTION_FLAG_NO_ARG: guint = 8;
pub const G_OPTION_FLAG_FILENAME: guint = 16;
pub const G_OPTION_FLAG_OPTIONAL_ARG: guint = 32;
pub const G_OPTION_FLAG_NOALIAS: guint = 64;

pub enum GOptionGroup { }

pub type GOptionParseFunc = extern "C" fn (*mut GOptionContext, *mut GOptionGroup, gpointer) -> gboolean;

pub const G_PDP_ENDIAN: gint = 3412;

pub const G_PI: gdouble = 3.141593;

pub const G_PI_2: gdouble = 1.570796;

pub const G_PI_4: gdouble = 0.785398;

pub const G_PRIORITY_DEFAULT: gint = 0;

pub const G_PRIORITY_DEFAULT_IDLE: gint = 200;

pub const G_PRIORITY_HIGH: gint = -100;

pub const G_PRIORITY_HIGH_IDLE: gint = 100;

pub const G_PRIORITY_LOW: gint = 300;

#[repr(C)]
pub struct GPatternSpec(gpointer);

#[repr(C)]
pub struct GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}

pub type GPollFunc = extern "C" fn (*mut GPollFD, guint, gint) -> gint;

pub type GPrintFunc = extern "C" fn (*const gchar);

#[repr(C)]
pub struct GPrivate {
    p: gpointer,
    notify: Option<GDestroyNotify>,
    future: [gpointer; 2],
}

#[repr(C)]
pub struct GPtrArray {
    pub pdata: gpointer,
    pub len: guint,
}

#[repr(C)]
pub struct GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}

#[repr(C)]
pub struct GRWLock {
    p: gpointer,
    i: [guint; 2],
}

#[repr(C)]
pub struct GRand(gpointer);

#[repr(C)]
pub struct GRecMutex {
    p: gpointer,
    i: [guint; 2],
}

pub enum GRegex { }

#[repr(C)]
pub enum GRegexCompileFlags {
    Caseless = 1,
    Multiline = 2,
    Dotall = 4,
    Extended = 8,
    Anchored = 16,
    DollarEndonly = 32,
    Ungreedy = 512,
    Raw = 2048,
    NoAutoCapture = 4096,
    Optimize = 8192,
    Firstline = 262144,
    Dupnames = 524288,
    NewlineCr = 1048576,
    NewlineLf = 2097152,
    NewlineCrlf = 3145728,
    NewlineAnycrlf = 5242880,
    BsrAnycrlf = 8388608,
    JavascriptCompat = 33554432,
}
pub const G_REGEX_CASELESS: guint = 1;
pub const G_REGEX_MULTILINE: guint = 2;
pub const G_REGEX_DOTALL: guint = 4;
pub const G_REGEX_EXTENDED: guint = 8;
pub const G_REGEX_ANCHORED: guint = 16;
pub const G_REGEX_DOLLAR_ENDONLY: guint = 32;
pub const G_REGEX_UNGREEDY: guint = 512;
pub const G_REGEX_RAW: guint = 2048;
pub const G_REGEX_NO_AUTO_CAPTURE: guint = 4096;
pub const G_REGEX_OPTIMIZE: guint = 8192;
pub const G_REGEX_FIRSTLINE: guint = 262144;
pub const G_REGEX_DUPNAMES: guint = 524288;
pub const G_REGEX_NEWLINE_CR: guint = 1048576;
pub const G_REGEX_NEWLINE_LF: guint = 2097152;
pub const G_REGEX_NEWLINE_CRLF: guint = 3145728;
pub const G_REGEX_NEWLINE_ANYCRLF: guint = 5242880;
pub const G_REGEX_BSR_ANYCRLF: guint = 8388608;
pub const G_REGEX_JAVASCRIPT_COMPAT: guint = 33554432;

#[repr(C)]
pub enum GRegexError {
    Compile = 0,
    Optimize = 1,
    Replace = 2,
    Match = 3,
    Internal = 4,
    StrayBackslash = 101,
    MissingControlChar = 102,
    UnrecognizedEscape = 103,
    QuantifiersOutOfOrder = 104,
    QuantifierTooBig = 105,
    UnterminatedCharacterClass = 106,
    InvalidEscapeInCharacterClass = 107,
    RangeOutOfOrder = 108,
    NothingToRepeat = 109,
    UnrecognizedCharacter = 112,
    PosixNamedClassOutsideClass = 113,
    UnmatchedParenthesis = 114,
    InexistentSubpatternReference = 115,
    UnterminatedComment = 118,
    ExpressionTooLarge = 120,
    MemoryError = 121,
    VariableLengthLookbehind = 125,
    MalformedCondition = 126,
    TooManyConditionalBranches = 127,
    AssertionExpected = 128,
    UnknownPosixClassName = 130,
    PosixCollatingElementsNotSupported = 131,
    HexCodeTooLarge = 134,
    InvalidCondition = 135,
    SingleByteMatchInLookbehind = 136,
    InfiniteLoop = 140,
    MissingSubpatternNameTerminator = 142,
    DuplicateSubpatternName = 143,
    MalformedProperty = 146,
    UnknownProperty = 147,
    SubpatternNameTooLong = 148,
    TooManySubpatterns = 149,
    InvalidOctalValue = 151,
    TooManyBranchesInDefine = 154,
    DefineRepetion = 155,
    InconsistentNewlineOptions = 156,
    MissingBackReference = 157,
    InvalidRelativeReference = 158,
    BacktrackingControlVerbArgumentForbidden = 159,
    UnknownBacktrackingControlVerb = 160,
    NumberTooBig = 161,
    MissingSubpatternName = 162,
    MissingDigit = 163,
    InvalidDataCharacter = 164,
    ExtraSubpatternName = 165,
    BacktrackingControlVerbArgumentRequired = 166,
    InvalidControlChar = 168,
    MissingName = 169,
    NotSupportedInClass = 171,
    TooManyForwardReferences = 172,
    NameTooLong = 175,
    CharacterValueTooLarge = 176,
}
pub const G_REGEX_ERROR_COMPILE: GRegexError = GRegexError::Compile;
pub const G_REGEX_ERROR_OPTIMIZE: GRegexError = GRegexError::Optimize;
pub const G_REGEX_ERROR_REPLACE: GRegexError = GRegexError::Replace;
pub const G_REGEX_ERROR_MATCH: GRegexError = GRegexError::Match;
pub const G_REGEX_ERROR_INTERNAL: GRegexError = GRegexError::Internal;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = GRegexError::StrayBackslash;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = GRegexError::MissingControlChar;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = GRegexError::UnrecognizedEscape;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = GRegexError::QuantifiersOutOfOrder;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = GRegexError::QuantifierTooBig;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = GRegexError::UnterminatedCharacterClass;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = GRegexError::InvalidEscapeInCharacterClass;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = GRegexError::RangeOutOfOrder;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = GRegexError::NothingToRepeat;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = GRegexError::UnrecognizedCharacter;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = GRegexError::PosixNamedClassOutsideClass;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = GRegexError::UnmatchedParenthesis;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = GRegexError::InexistentSubpatternReference;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = GRegexError::UnterminatedComment;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = GRegexError::ExpressionTooLarge;
pub const G_REGEX_ERROR_MEMORY_ERROR: GRegexError = GRegexError::MemoryError;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = GRegexError::VariableLengthLookbehind;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = GRegexError::MalformedCondition;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = GRegexError::TooManyConditionalBranches;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = GRegexError::AssertionExpected;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = GRegexError::UnknownPosixClassName;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = GRegexError::PosixCollatingElementsNotSupported;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = GRegexError::HexCodeTooLarge;
pub const G_REGEX_ERROR_INVALID_CONDITION: GRegexError = GRegexError::InvalidCondition;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = GRegexError::SingleByteMatchInLookbehind;
pub const G_REGEX_ERROR_INFINITE_LOOP: GRegexError = GRegexError::InfiniteLoop;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = GRegexError::MissingSubpatternNameTerminator;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = GRegexError::DuplicateSubpatternName;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = GRegexError::MalformedProperty;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = GRegexError::UnknownProperty;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = GRegexError::SubpatternNameTooLong;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = GRegexError::TooManySubpatterns;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = GRegexError::InvalidOctalValue;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = GRegexError::TooManyBranchesInDefine;
pub const G_REGEX_ERROR_DEFINE_REPETION: GRegexError = GRegexError::DefineRepetion;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = GRegexError::InconsistentNewlineOptions;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = GRegexError::MissingBackReference;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = GRegexError::InvalidRelativeReference;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = GRegexError::BacktrackingControlVerbArgumentForbidden;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = GRegexError::UnknownBacktrackingControlVerb;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = GRegexError::NumberTooBig;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = GRegexError::MissingSubpatternName;
pub const G_REGEX_ERROR_MISSING_DIGIT: GRegexError = GRegexError::MissingDigit;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = GRegexError::InvalidDataCharacter;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = GRegexError::ExtraSubpatternName;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = GRegexError::BacktrackingControlVerbArgumentRequired;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = GRegexError::InvalidControlChar;
pub const G_REGEX_ERROR_MISSING_NAME: GRegexError = GRegexError::MissingName;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = GRegexError::NotSupportedInClass;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = GRegexError::TooManyForwardReferences;
pub const G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = GRegexError::NameTooLong;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = GRegexError::CharacterValueTooLarge;

pub type GRegexEvalCallback = extern "C" fn (*const GMatchInfo, *mut GString, gpointer) -> gboolean;

#[repr(C)]
pub enum GRegexMatchFlags {
    Anchored = 16,
    Notbol = 128,
    Noteol = 256,
    Notempty = 1024,
    Partial = 32768,
    NewlineCr = 1048576,
    NewlineLf = 2097152,
    NewlineCrlf = 3145728,
    NewlineAny = 4194304,
    NewlineAnycrlf = 5242880,
    BsrAnycrlf = 8388608,
    BsrAny = 16777216,
    PartialHard = 134217728,
    NotemptyAtstart = 268435456,
}
pub const G_REGEX_MATCH_ANCHORED: guint = 16;
pub const G_REGEX_MATCH_NOTBOL: guint = 128;
pub const G_REGEX_MATCH_NOTEOL: guint = 256;
pub const G_REGEX_MATCH_NOTEMPTY: guint = 1024;
pub const G_REGEX_MATCH_PARTIAL: guint = 32768;
pub const G_REGEX_MATCH_NEWLINE_CR: guint = 1048576;
pub const G_REGEX_MATCH_NEWLINE_LF: guint = 2097152;
pub const G_REGEX_MATCH_NEWLINE_CRLF: guint = 3145728;
pub const G_REGEX_MATCH_NEWLINE_ANY: guint = 4194304;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF: guint = 5242880;
pub const G_REGEX_MATCH_BSR_ANYCRLF: guint = 8388608;
pub const G_REGEX_MATCH_BSR_ANY: guint = 16777216;
pub const G_REGEX_MATCH_PARTIAL_SOFT: guint = 32768;
pub const G_REGEX_MATCH_PARTIAL_HARD: guint = 134217728;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART: guint = 268435456;

#[repr(C)]
pub struct GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}

pub const G_SOURCE_CONTINUE: gboolean = TRUE;

pub const G_SOURCE_REMOVE: gboolean = FALSE;

pub const G_SQRT2: gdouble = 1.414214;

pub const G_STR_DELIMITERS: &'static [u8] = b"_-|> <.\0";

#[repr(C)]
pub struct GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    symbol_table: *mut GHashTable,
    input_fd: gint,
    text: *const gchar,
    text_end: *const gchar,
    buffer: *mut gchar,
    scope_id: guint,
    pub msg_handler: Option<GScannerMsgFunc>,
}

pub type GScannerMsgFunc = extern "C" fn (*mut GScanner, *mut gchar, gboolean);

#[repr(C)]
pub enum GSeekType {
    Cur = 0,
    Set = 1,
    End = 2,
}
pub const G_SEEK_CUR: GSeekType = GSeekType::Cur;
pub const G_SEEK_SET: GSeekType = GSeekType::Set;
pub const G_SEEK_END: GSeekType = GSeekType::End;

#[repr(C)]
pub struct GSequence(gpointer);

#[repr(C)]
pub struct GSequenceIter(gpointer);

pub type GSequenceIterCompareFunc = extern "C" fn (*mut GSequenceIter, *mut GSequenceIter, gpointer) -> gint;

#[repr(C)]
pub enum GShellError {
    BadQuoting = 0,
    EmptyString = 1,
    Failed = 2,
}
pub const G_SHELL_ERROR_BAD_QUOTING: GShellError = GShellError::BadQuoting;
pub const G_SHELL_ERROR_EMPTY_STRING: GShellError = GShellError::EmptyString;
pub const G_SHELL_ERROR_FAILED: GShellError = GShellError::Failed;

#[repr(C)]
pub enum GSliceConfig {
    AlwaysMalloc = 1,
    BypassMagazines = 2,
    WorkingSetMsecs = 3,
    ColorIncrement = 4,
    ChunkSizes = 5,
    ContentionCounter = 6,
}
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = GSliceConfig::AlwaysMalloc;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = GSliceConfig::BypassMagazines;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = GSliceConfig::WorkingSetMsecs;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = GSliceConfig::ColorIncrement;
pub const G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = GSliceConfig::ChunkSizes;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = GSliceConfig::ContentionCounter;

#[repr(C)]
pub struct GSource {
    callback_data: gpointer,
    callback_funcs: *mut GSourceCallbackFuncs,
    source_funcs: *const GSourceFuncs,
    ref_count: guint,
    context: *mut GMainContext,
    priority: gint,
    flags: guint,
    source_id: guint,
    poll_fds: *mut GSList,
    prev: *mut GSource,
    next: *mut GSource,
    name: *mut gchar,
    priv_: *mut GSourcePrivate,
}

#[repr(C)]
pub struct GSourceCallbackFuncs {
    pub ref_: Option<extern "C" fn (gpointer)>,
    pub unref: Option<extern "C" fn (gpointer)>,
    pub get: Option<extern "C" fn (gpointer, *mut GSource, *mut GSourceFunc, gpointer)>,
}

pub type GSourceDummyMarshal = extern "C" fn ();

pub type GSourceFunc = extern "C" fn (gpointer) -> gboolean;

#[repr(C)]
pub struct GSourceFuncs {
    pub prepare: Option<extern "C" fn (*mut GSource, gint) -> gboolean>,
    pub check: Option<extern "C" fn (*mut GSource) -> gboolean>,
    pub dispatch: Option<extern "C" fn (*mut GSource, GSourceFunc, gpointer) -> gboolean>,
    pub finalize: Option<extern "C" fn (*mut GSource)>,
    closure_callback: Option<GSourceFunc>,
    closure_marshal: Option<GSourceDummyMarshal>,
}

#[repr(C)]
pub struct GSourcePrivate(gpointer);

pub type GSpawnChildSetupFunc = extern "C" fn (gpointer);

#[repr(C)]
pub enum GSpawnError {
    Fork = 0,
    Read = 1,
    Chdir = 2,
    Acces = 3,
    Perm = 4,
    TooBig = 5,
    Noexec = 6,
    Nametoolong = 7,
    Noent = 8,
    Nomem = 9,
    Notdir = 10,
    Loop = 11,
    Txtbusy = 12,
    Io = 13,
    Nfile = 14,
    Mfile = 15,
    Inval = 16,
    Isdir = 17,
    Libbad = 18,
    Failed = 19,
}
pub const G_SPAWN_ERROR_FORK: GSpawnError = GSpawnError::Fork;
pub const G_SPAWN_ERROR_READ: GSpawnError = GSpawnError::Read;
pub const G_SPAWN_ERROR_CHDIR: GSpawnError = GSpawnError::Chdir;
pub const G_SPAWN_ERROR_ACCES: GSpawnError = GSpawnError::Acces;
pub const G_SPAWN_ERROR_PERM: GSpawnError = GSpawnError::Perm;
pub const G_SPAWN_ERROR_TOO_BIG: GSpawnError = GSpawnError::TooBig;
pub const G_SPAWN_ERROR_2BIG: GSpawnError = GSpawnError::TooBig;
pub const G_SPAWN_ERROR_NOEXEC: GSpawnError = GSpawnError::Noexec;
pub const G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = GSpawnError::Nametoolong;
pub const G_SPAWN_ERROR_NOENT: GSpawnError = GSpawnError::Noent;
pub const G_SPAWN_ERROR_NOMEM: GSpawnError = GSpawnError::Nomem;
pub const G_SPAWN_ERROR_NOTDIR: GSpawnError = GSpawnError::Notdir;
pub const G_SPAWN_ERROR_LOOP: GSpawnError = GSpawnError::Loop;
pub const G_SPAWN_ERROR_TXTBUSY: GSpawnError = GSpawnError::Txtbusy;
pub const G_SPAWN_ERROR_IO: GSpawnError = GSpawnError::Io;
pub const G_SPAWN_ERROR_NFILE: GSpawnError = GSpawnError::Nfile;
pub const G_SPAWN_ERROR_MFILE: GSpawnError = GSpawnError::Mfile;
pub const G_SPAWN_ERROR_INVAL: GSpawnError = GSpawnError::Inval;
pub const G_SPAWN_ERROR_ISDIR: GSpawnError = GSpawnError::Isdir;
pub const G_SPAWN_ERROR_LIBBAD: GSpawnError = GSpawnError::Libbad;
pub const G_SPAWN_ERROR_FAILED: GSpawnError = GSpawnError::Failed;

#[repr(C)]
pub enum GSpawnFlags {
    Default = 0,
    LeaveDescriptorsOpen = 1,
    DoNotReapChild = 2,
    SearchPath = 4,
    StdoutToDevNull = 8,
    StderrToDevNull = 16,
    ChildInheritsStdin = 32,
    FileAndArgvZero = 64,
    SearchPathFromEnvp = 128,
    CloexecPipes = 256,
}
pub const G_SPAWN_DEFAULT: guint = 0;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN: guint = 1;
pub const G_SPAWN_DO_NOT_REAP_CHILD: guint = 2;
pub const G_SPAWN_SEARCH_PATH: guint = 4;
pub const G_SPAWN_STDOUT_TO_DEV_NULL: guint = 8;
pub const G_SPAWN_STDERR_TO_DEV_NULL: guint = 16;
pub const G_SPAWN_CHILD_INHERITS_STDIN: guint = 32;
pub const G_SPAWN_FILE_AND_ARGV_ZERO: guint = 64;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP: guint = 128;
pub const G_SPAWN_CLOEXEC_PIPES: guint = 256;

#[repr(C)]
pub struct GStatBuf(gpointer);

#[repr(C)]
pub struct GString {
    pub str: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}

#[repr(C)]
pub struct GStringChunk(gpointer);

pub const G_TIME_SPAN_DAY: i64 = 86400000000;

pub const G_TIME_SPAN_HOUR: i64 = 3600000000;

pub const G_TIME_SPAN_MILLISECOND: i64 = 1000;

pub const G_TIME_SPAN_MINUTE: i64 = 60000000;

pub const G_TIME_SPAN_SECOND: i64 = 1000000;

#[repr(C)]
pub struct GTestCase(gpointer);

#[repr(C)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}

pub type GTestDataFunc = extern "C" fn (gconstpointer);

#[repr(C)]
pub enum GTestFileType {
    Dist = 0,
    Built = 1,
}
pub const G_TEST_DIST: GTestFileType = GTestFileType::Dist;
pub const G_TEST_BUILT: GTestFileType = GTestFileType::Built;

pub type GTestFixtureFunc = extern "C" fn (gpointer, gconstpointer);

pub type GTestFunc = extern "C" fn ();

#[repr(C)]
pub struct GTestLogBuffer {
    data: *mut GString,
    msgs: *mut GSList,
}

pub type GTestLogFatalFunc = extern "C" fn (*const gchar, GLogLevelFlags, *const gchar, gpointer) -> gboolean;

#[repr(C)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: glong,
}

#[repr(C)]
pub enum GTestLogType {
    None = 0,
    Error = 1,
    StartBinary = 2,
    ListCase = 3,
    SkipCase = 4,
    StartCase = 5,
    StopCase = 6,
    MinResult = 7,
    MaxResult = 8,
    Message = 9,
    StartSuite = 10,
    StopSuite = 11,
}
pub const G_TEST_LOG_NONE: GTestLogType = GTestLogType::None;
pub const G_TEST_LOG_ERROR: GTestLogType = GTestLogType::Error;
pub const G_TEST_LOG_START_BINARY: GTestLogType = GTestLogType::StartBinary;
pub const G_TEST_LOG_LIST_CASE: GTestLogType = GTestLogType::ListCase;
pub const G_TEST_LOG_SKIP_CASE: GTestLogType = GTestLogType::SkipCase;
pub const G_TEST_LOG_START_CASE: GTestLogType = GTestLogType::StartCase;
pub const G_TEST_LOG_STOP_CASE: GTestLogType = GTestLogType::StopCase;
pub const G_TEST_LOG_MIN_RESULT: GTestLogType = GTestLogType::MinResult;
pub const G_TEST_LOG_MAX_RESULT: GTestLogType = GTestLogType::MaxResult;
pub const G_TEST_LOG_MESSAGE: GTestLogType = GTestLogType::Message;
pub const G_TEST_LOG_START_SUITE: GTestLogType = GTestLogType::StartSuite;
pub const G_TEST_LOG_STOP_SUITE: GTestLogType = GTestLogType::StopSuite;

#[repr(C)]
pub enum GTestSubprocessFlags {
    Stdin = 1,
    Stdout = 2,
    Stderr = 4,
}
pub const G_TEST_SUBPROCESS_INHERIT_STDIN: guint = 1;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT: guint = 2;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR: guint = 4;

#[repr(C)]
pub struct GTestSuite(gpointer);

#[repr(C)]
pub enum GTestTrapFlags {
    SilenceStdout = 128,
    SilenceStderr = 256,
    InheritStdin = 512,
}
pub const G_TEST_TRAP_SILENCE_STDOUT: guint = 128;
pub const G_TEST_TRAP_SILENCE_STDERR: guint = 256;
pub const G_TEST_TRAP_INHERIT_STDIN: guint = 512;

pub enum GThread { }

#[repr(C)]
pub enum GThreadError {
    ThreadErrorAgain = 0,
    _Dummy = 1,
}
pub const G_THREAD_ERROR_AGAIN: GThreadError = GThreadError::ThreadErrorAgain;

pub type GThreadFunc = extern "C" fn (gpointer) -> gpointer;

#[repr(C)]
pub struct GThreadPool {
    pub func: Option<GFunc>,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}

#[repr(C)]
pub enum GTimeType {
    Standard = 0,
    Daylight = 1,
    Universal = 2,
}
pub const G_TIME_TYPE_STANDARD: GTimeType = GTimeType::Standard;
pub const G_TIME_TYPE_DAYLIGHT: GTimeType = GTimeType::Daylight;
pub const G_TIME_TYPE_UNIVERSAL: GTimeType = GTimeType::Universal;

#[repr(C)]
pub struct GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}

pub enum GTimeZone { }

#[repr(C)]
pub struct GTimer(gpointer);

#[repr(C)]
pub enum GTokenType {
    Eof = 0,
    LeftParen = 40,
    RightParen = 41,
    Comma = 44,
    EqualSign = 61,
    LeftBrace = 91,
    RightBrace = 93,
    LeftCurly = 123,
    RightCurly = 125,
    None = 256,
    Error = 257,
    Char = 258,
    Binary = 259,
    Octal = 260,
    Int = 261,
    Hex = 262,
    Float = 263,
    String = 264,
    Symbol = 265,
    Identifier = 266,
    IdentifierNull = 267,
    CommentSingle = 268,
    CommentMulti = 269,
}
pub const G_TOKEN_EOF: GTokenType = GTokenType::Eof;
pub const G_TOKEN_LEFT_PAREN: GTokenType = GTokenType::LeftParen;
pub const G_TOKEN_RIGHT_PAREN: GTokenType = GTokenType::RightParen;
pub const G_TOKEN_LEFT_CURLY: GTokenType = GTokenType::LeftCurly;
pub const G_TOKEN_RIGHT_CURLY: GTokenType = GTokenType::RightCurly;
pub const G_TOKEN_LEFT_BRACE: GTokenType = GTokenType::LeftBrace;
pub const G_TOKEN_RIGHT_BRACE: GTokenType = GTokenType::RightBrace;
pub const G_TOKEN_EQUAL_SIGN: GTokenType = GTokenType::EqualSign;
pub const G_TOKEN_COMMA: GTokenType = GTokenType::Comma;
pub const G_TOKEN_NONE: GTokenType = GTokenType::None;
pub const G_TOKEN_ERROR: GTokenType = GTokenType::Error;
pub const G_TOKEN_CHAR: GTokenType = GTokenType::Char;
pub const G_TOKEN_BINARY: GTokenType = GTokenType::Binary;
pub const G_TOKEN_OCTAL: GTokenType = GTokenType::Octal;
pub const G_TOKEN_INT: GTokenType = GTokenType::Int;
pub const G_TOKEN_HEX: GTokenType = GTokenType::Hex;
pub const G_TOKEN_FLOAT: GTokenType = GTokenType::Float;
pub const G_TOKEN_STRING: GTokenType = GTokenType::String;
pub const G_TOKEN_SYMBOL: GTokenType = GTokenType::Symbol;
pub const G_TOKEN_IDENTIFIER: GTokenType = GTokenType::Identifier;
pub const G_TOKEN_IDENTIFIER_NULL: GTokenType = GTokenType::IdentifierNull;
pub const G_TOKEN_COMMENT_SINGLE: GTokenType = GTokenType::CommentSingle;
pub const G_TOKEN_COMMENT_MULTI: GTokenType = GTokenType::CommentMulti;

pub type GTranslateFunc = extern "C" fn (*const gchar, gpointer) -> *const gchar;

#[repr(C)]
pub struct GTrashStack {
    pub next: *mut GTrashStack,
}

#[repr(C)]
pub enum GTraverseFlags {
    Leaves = 1,
    NonLeaves = 2,
    All = 3,
}
pub const G_TRAVERSE_LEAVES: guint = 1;
pub const G_TRAVERSE_NON_LEAVES: guint = 2;
pub const G_TRAVERSE_ALL: guint = 3;
pub const G_TRAVERSE_MASK: guint = 3;
pub const G_TRAVERSE_LEAFS: guint = 1;
pub const G_TRAVERSE_NON_LEAFS: guint = 2;

pub type GTraverseFunc = extern "C" fn (gpointer, gpointer, gpointer) -> gboolean;

#[repr(C)]
pub enum GTraverseType {
    InOrder = 0,
    PreOrder = 1,
    PostOrder = 2,
    LevelOrder = 3,
}
pub const G_IN_ORDER: GTraverseType = GTraverseType::InOrder;
pub const G_PRE_ORDER: GTraverseType = GTraverseType::PreOrder;
pub const G_POST_ORDER: GTraverseType = GTraverseType::PostOrder;
pub const G_LEVEL_ORDER: GTraverseType = GTraverseType::LevelOrder;

#[repr(C)]
pub struct GTree(gpointer);

pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: gint = 18;

pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &'static [u8] = b":/?#[]@\0";

pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &'static [u8] = b"!$&'()*+,;=\0";

pub const G_USEC_PER_SEC: gint = 1000000;

#[repr(C)]
pub enum GUnicodeBreakType {
    Mandatory = 0,
    CarriageReturn = 1,
    LineFeed = 2,
    CombiningMark = 3,
    Surrogate = 4,
    ZeroWidthSpace = 5,
    Inseparable = 6,
    NonBreakingGlue = 7,
    Contingent = 8,
    Space = 9,
    After = 10,
    Before = 11,
    BeforeAndAfter = 12,
    Hyphen = 13,
    NonStarter = 14,
    OpenPunctuation = 15,
    ClosePunctuation = 16,
    Quotation = 17,
    Exclamation = 18,
    Ideographic = 19,
    Numeric = 20,
    InfixSeparator = 21,
    Symbol = 22,
    Alphabetic = 23,
    Prefix = 24,
    Postfix = 25,
    ComplexContext = 26,
    Ambiguous = 27,
    Unknown = 28,
    NextLine = 29,
    WordJoiner = 30,
    HangulLJamo = 31,
    HangulVJamo = 32,
    HangulTJamo = 33,
    HangulLvSyllable = 34,
    HangulLvtSyllable = 35,
    CloseParanthesis = 36,
    ConditionalJapaneseStarter = 37,
    HebrewLetter = 38,
    RegionalIndicator = 39,
}
pub const G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = GUnicodeBreakType::Mandatory;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = GUnicodeBreakType::CarriageReturn;
pub const G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = GUnicodeBreakType::LineFeed;
pub const G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = GUnicodeBreakType::CombiningMark;
pub const G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = GUnicodeBreakType::Surrogate;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = GUnicodeBreakType::ZeroWidthSpace;
pub const G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = GUnicodeBreakType::Inseparable;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = GUnicodeBreakType::NonBreakingGlue;
pub const G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = GUnicodeBreakType::Contingent;
pub const G_UNICODE_BREAK_SPACE: GUnicodeBreakType = GUnicodeBreakType::Space;
pub const G_UNICODE_BREAK_AFTER: GUnicodeBreakType = GUnicodeBreakType::After;
pub const G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = GUnicodeBreakType::Before;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = GUnicodeBreakType::BeforeAndAfter;
pub const G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = GUnicodeBreakType::Hyphen;
pub const G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = GUnicodeBreakType::NonStarter;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = GUnicodeBreakType::OpenPunctuation;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = GUnicodeBreakType::ClosePunctuation;
pub const G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = GUnicodeBreakType::Quotation;
pub const G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = GUnicodeBreakType::Exclamation;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = GUnicodeBreakType::Ideographic;
pub const G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = GUnicodeBreakType::Numeric;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = GUnicodeBreakType::InfixSeparator;
pub const G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = GUnicodeBreakType::Symbol;
pub const G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = GUnicodeBreakType::Alphabetic;
pub const G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = GUnicodeBreakType::Prefix;
pub const G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = GUnicodeBreakType::Postfix;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = GUnicodeBreakType::ComplexContext;
pub const G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = GUnicodeBreakType::Ambiguous;
pub const G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = GUnicodeBreakType::Unknown;
pub const G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = GUnicodeBreakType::NextLine;
pub const G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = GUnicodeBreakType::WordJoiner;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = GUnicodeBreakType::HangulLJamo;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = GUnicodeBreakType::HangulVJamo;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = GUnicodeBreakType::HangulTJamo;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = GUnicodeBreakType::HangulLvSyllable;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = GUnicodeBreakType::HangulLvtSyllable;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = GUnicodeBreakType::CloseParanthesis;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = GUnicodeBreakType::ConditionalJapaneseStarter;
pub const G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = GUnicodeBreakType::HebrewLetter;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = GUnicodeBreakType::RegionalIndicator;

#[repr(C)]
pub enum GUnicodeScript {
    InvalidCode = -1,
    Common = 0,
    Inherited = 1,
    Arabic = 2,
    Armenian = 3,
    Bengali = 4,
    Bopomofo = 5,
    Cherokee = 6,
    Coptic = 7,
    Cyrillic = 8,
    Deseret = 9,
    Devanagari = 10,
    Ethiopic = 11,
    Georgian = 12,
    Gothic = 13,
    Greek = 14,
    Gujarati = 15,
    Gurmukhi = 16,
    Han = 17,
    Hangul = 18,
    Hebrew = 19,
    Hiragana = 20,
    Kannada = 21,
    Katakana = 22,
    Khmer = 23,
    Lao = 24,
    Latin = 25,
    Malayalam = 26,
    Mongolian = 27,
    Myanmar = 28,
    Ogham = 29,
    OldItalic = 30,
    Oriya = 31,
    Runic = 32,
    Sinhala = 33,
    Syriac = 34,
    Tamil = 35,
    Telugu = 36,
    Thaana = 37,
    Thai = 38,
    Tibetan = 39,
    CanadianAboriginal = 40,
    Yi = 41,
    Tagalog = 42,
    Hanunoo = 43,
    Buhid = 44,
    Tagbanwa = 45,
    Braille = 46,
    Cypriot = 47,
    Limbu = 48,
    Osmanya = 49,
    Shavian = 50,
    LinearB = 51,
    TaiLe = 52,
    Ugaritic = 53,
    NewTaiLue = 54,
    Buginese = 55,
    Glagolitic = 56,
    Tifinagh = 57,
    SylotiNagri = 58,
    OldPersian = 59,
    Kharoshthi = 60,
    Unknown = 61,
    Balinese = 62,
    Cuneiform = 63,
    Phoenician = 64,
    PhagsPa = 65,
    Nko = 66,
    KayahLi = 67,
    Lepcha = 68,
    Rejang = 69,
    Sundanese = 70,
    Saurashtra = 71,
    Cham = 72,
    OlChiki = 73,
    Vai = 74,
    Carian = 75,
    Lycian = 76,
    Lydian = 77,
    Avestan = 78,
    Bamum = 79,
    EgyptianHieroglyphs = 80,
    ImperialAramaic = 81,
    InscriptionalPahlavi = 82,
    InscriptionalParthian = 83,
    Javanese = 84,
    Kaithi = 85,
    Lisu = 86,
    MeeteiMayek = 87,
    OldSouthArabian = 88,
    OldTurkic = 89,
    Samaritan = 90,
    TaiTham = 91,
    TaiViet = 92,
    Batak = 93,
    Brahmi = 94,
    Mandaic = 95,
    Chakma = 96,
    MeroiticCursive = 97,
    MeroiticHieroglyphs = 98,
    Miao = 99,
    Sharada = 100,
    SoraSompeng = 101,
    Takri = 102,
    BassaVah = 103,
    CaucasianAlbanian = 104,
    Duployan = 105,
    Elbasan = 106,
    Grantha = 107,
    Khojki = 108,
    Khudawadi = 109,
    LinearA = 110,
    Mahajani = 111,
    Manichaean = 112,
    MendeKikakui = 113,
    Modi = 114,
    Mro = 115,
    Nabataean = 116,
    OldNorthArabian = 117,
    OldPermic = 118,
    PahawhHmong = 119,
    Palmyrene = 120,
    PauCinHau = 121,
    PsalterPahlavi = 122,
    Siddham = 123,
    Tirhuta = 124,
    WarangCiti = 125,
    Ahom = 126,
    AnatolianHieroglyphs = 127,
    Hatran = 128,
    Multani = 129,
    OldHungarian = 130,
    Signwriting = 131,
}
pub const G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = GUnicodeScript::InvalidCode;
pub const G_UNICODE_SCRIPT_COMMON: GUnicodeScript = GUnicodeScript::Common;
pub const G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = GUnicodeScript::Inherited;
pub const G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = GUnicodeScript::Arabic;
pub const G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = GUnicodeScript::Armenian;
pub const G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = GUnicodeScript::Bengali;
pub const G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = GUnicodeScript::Bopomofo;
pub const G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = GUnicodeScript::Cherokee;
pub const G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = GUnicodeScript::Coptic;
pub const G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = GUnicodeScript::Cyrillic;
pub const G_UNICODE_SCRIPT_DESERET: GUnicodeScript = GUnicodeScript::Deseret;
pub const G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = GUnicodeScript::Devanagari;
pub const G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = GUnicodeScript::Ethiopic;
pub const G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = GUnicodeScript::Georgian;
pub const G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = GUnicodeScript::Gothic;
pub const G_UNICODE_SCRIPT_GREEK: GUnicodeScript = GUnicodeScript::Greek;
pub const G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = GUnicodeScript::Gujarati;
pub const G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = GUnicodeScript::Gurmukhi;
pub const G_UNICODE_SCRIPT_HAN: GUnicodeScript = GUnicodeScript::Han;
pub const G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = GUnicodeScript::Hangul;
pub const G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = GUnicodeScript::Hebrew;
pub const G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = GUnicodeScript::Hiragana;
pub const G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = GUnicodeScript::Kannada;
pub const G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = GUnicodeScript::Katakana;
pub const G_UNICODE_SCRIPT_KHMER: GUnicodeScript = GUnicodeScript::Khmer;
pub const G_UNICODE_SCRIPT_LAO: GUnicodeScript = GUnicodeScript::Lao;
pub const G_UNICODE_SCRIPT_LATIN: GUnicodeScript = GUnicodeScript::Latin;
pub const G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = GUnicodeScript::Malayalam;
pub const G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = GUnicodeScript::Mongolian;
pub const G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = GUnicodeScript::Myanmar;
pub const G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = GUnicodeScript::Ogham;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = GUnicodeScript::OldItalic;
pub const G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = GUnicodeScript::Oriya;
pub const G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = GUnicodeScript::Runic;
pub const G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = GUnicodeScript::Sinhala;
pub const G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = GUnicodeScript::Syriac;
pub const G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = GUnicodeScript::Tamil;
pub const G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = GUnicodeScript::Telugu;
pub const G_UNICODE_SCRIPT_THAANA: GUnicodeScript = GUnicodeScript::Thaana;
pub const G_UNICODE_SCRIPT_THAI: GUnicodeScript = GUnicodeScript::Thai;
pub const G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = GUnicodeScript::Tibetan;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = GUnicodeScript::CanadianAboriginal;
pub const G_UNICODE_SCRIPT_YI: GUnicodeScript = GUnicodeScript::Yi;
pub const G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = GUnicodeScript::Tagalog;
pub const G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = GUnicodeScript::Hanunoo;
pub const G_UNICODE_SCRIPT_BUHID: GUnicodeScript = GUnicodeScript::Buhid;
pub const G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = GUnicodeScript::Tagbanwa;
pub const G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = GUnicodeScript::Braille;
pub const G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = GUnicodeScript::Cypriot;
pub const G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = GUnicodeScript::Limbu;
pub const G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = GUnicodeScript::Osmanya;
pub const G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = GUnicodeScript::Shavian;
pub const G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = GUnicodeScript::LinearB;
pub const G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = GUnicodeScript::TaiLe;
pub const G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = GUnicodeScript::Ugaritic;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = GUnicodeScript::NewTaiLue;
pub const G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = GUnicodeScript::Buginese;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = GUnicodeScript::Glagolitic;
pub const G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = GUnicodeScript::Tifinagh;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = GUnicodeScript::SylotiNagri;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = GUnicodeScript::OldPersian;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = GUnicodeScript::Kharoshthi;
pub const G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = GUnicodeScript::Unknown;
pub const G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = GUnicodeScript::Balinese;
pub const G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = GUnicodeScript::Cuneiform;
pub const G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = GUnicodeScript::Phoenician;
pub const G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = GUnicodeScript::PhagsPa;
pub const G_UNICODE_SCRIPT_NKO: GUnicodeScript = GUnicodeScript::Nko;
pub const G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = GUnicodeScript::KayahLi;
pub const G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = GUnicodeScript::Lepcha;
pub const G_UNICODE_SCRIPT_REJANG: GUnicodeScript = GUnicodeScript::Rejang;
pub const G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = GUnicodeScript::Sundanese;
pub const G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = GUnicodeScript::Saurashtra;
pub const G_UNICODE_SCRIPT_CHAM: GUnicodeScript = GUnicodeScript::Cham;
pub const G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = GUnicodeScript::OlChiki;
pub const G_UNICODE_SCRIPT_VAI: GUnicodeScript = GUnicodeScript::Vai;
pub const G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = GUnicodeScript::Carian;
pub const G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = GUnicodeScript::Lycian;
pub const G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = GUnicodeScript::Lydian;
pub const G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = GUnicodeScript::Avestan;
pub const G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = GUnicodeScript::Bamum;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = GUnicodeScript::EgyptianHieroglyphs;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = GUnicodeScript::ImperialAramaic;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = GUnicodeScript::InscriptionalPahlavi;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = GUnicodeScript::InscriptionalParthian;
pub const G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = GUnicodeScript::Javanese;
pub const G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = GUnicodeScript::Kaithi;
pub const G_UNICODE_SCRIPT_LISU: GUnicodeScript = GUnicodeScript::Lisu;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = GUnicodeScript::MeeteiMayek;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = GUnicodeScript::OldSouthArabian;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = GUnicodeScript::OldTurkic;
pub const G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = GUnicodeScript::Samaritan;
pub const G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = GUnicodeScript::TaiTham;
pub const G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = GUnicodeScript::TaiViet;
pub const G_UNICODE_SCRIPT_BATAK: GUnicodeScript = GUnicodeScript::Batak;
pub const G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = GUnicodeScript::Brahmi;
pub const G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = GUnicodeScript::Mandaic;
pub const G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = GUnicodeScript::Chakma;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = GUnicodeScript::MeroiticCursive;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = GUnicodeScript::MeroiticHieroglyphs;
pub const G_UNICODE_SCRIPT_MIAO: GUnicodeScript = GUnicodeScript::Miao;
pub const G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = GUnicodeScript::Sharada;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = GUnicodeScript::SoraSompeng;
pub const G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = GUnicodeScript::Takri;
pub const G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = GUnicodeScript::BassaVah;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = GUnicodeScript::CaucasianAlbanian;
pub const G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = GUnicodeScript::Duployan;
pub const G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = GUnicodeScript::Elbasan;
pub const G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = GUnicodeScript::Grantha;
pub const G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = GUnicodeScript::Khojki;
pub const G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = GUnicodeScript::Khudawadi;
pub const G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = GUnicodeScript::LinearA;
pub const G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = GUnicodeScript::Mahajani;
pub const G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = GUnicodeScript::Manichaean;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = GUnicodeScript::MendeKikakui;
pub const G_UNICODE_SCRIPT_MODI: GUnicodeScript = GUnicodeScript::Modi;
pub const G_UNICODE_SCRIPT_MRO: GUnicodeScript = GUnicodeScript::Mro;
pub const G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = GUnicodeScript::Nabataean;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = GUnicodeScript::OldNorthArabian;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = GUnicodeScript::OldPermic;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = GUnicodeScript::PahawhHmong;
pub const G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = GUnicodeScript::Palmyrene;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = GUnicodeScript::PauCinHau;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = GUnicodeScript::PsalterPahlavi;
pub const G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = GUnicodeScript::Siddham;
pub const G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = GUnicodeScript::Tirhuta;
pub const G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = GUnicodeScript::WarangCiti;
pub const G_UNICODE_SCRIPT_AHOM: GUnicodeScript = GUnicodeScript::Ahom;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = GUnicodeScript::AnatolianHieroglyphs;
pub const G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = GUnicodeScript::Hatran;
pub const G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = GUnicodeScript::Multani;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = GUnicodeScript::OldHungarian;
pub const G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = GUnicodeScript::Signwriting;

#[repr(C)]
pub enum GUnicodeType {
    Control = 0,
    Format = 1,
    Unassigned = 2,
    PrivateUse = 3,
    Surrogate = 4,
    LowercaseLetter = 5,
    ModifierLetter = 6,
    OtherLetter = 7,
    TitlecaseLetter = 8,
    UppercaseLetter = 9,
    SpacingMark = 10,
    EnclosingMark = 11,
    NonSpacingMark = 12,
    DecimalNumber = 13,
    LetterNumber = 14,
    OtherNumber = 15,
    ConnectPunctuation = 16,
    DashPunctuation = 17,
    ClosePunctuation = 18,
    FinalPunctuation = 19,
    InitialPunctuation = 20,
    OtherPunctuation = 21,
    OpenPunctuation = 22,
    CurrencySymbol = 23,
    ModifierSymbol = 24,
    MathSymbol = 25,
    OtherSymbol = 26,
    LineSeparator = 27,
    ParagraphSeparator = 28,
    SpaceSeparator = 29,
}
pub const G_UNICODE_CONTROL: GUnicodeType = GUnicodeType::Control;
pub const G_UNICODE_FORMAT: GUnicodeType = GUnicodeType::Format;
pub const G_UNICODE_UNASSIGNED: GUnicodeType = GUnicodeType::Unassigned;
pub const G_UNICODE_PRIVATE_USE: GUnicodeType = GUnicodeType::PrivateUse;
pub const G_UNICODE_SURROGATE: GUnicodeType = GUnicodeType::Surrogate;
pub const G_UNICODE_LOWERCASE_LETTER: GUnicodeType = GUnicodeType::LowercaseLetter;
pub const G_UNICODE_MODIFIER_LETTER: GUnicodeType = GUnicodeType::ModifierLetter;
pub const G_UNICODE_OTHER_LETTER: GUnicodeType = GUnicodeType::OtherLetter;
pub const G_UNICODE_TITLECASE_LETTER: GUnicodeType = GUnicodeType::TitlecaseLetter;
pub const G_UNICODE_UPPERCASE_LETTER: GUnicodeType = GUnicodeType::UppercaseLetter;
pub const G_UNICODE_SPACING_MARK: GUnicodeType = GUnicodeType::SpacingMark;
pub const G_UNICODE_ENCLOSING_MARK: GUnicodeType = GUnicodeType::EnclosingMark;
pub const G_UNICODE_NON_SPACING_MARK: GUnicodeType = GUnicodeType::NonSpacingMark;
pub const G_UNICODE_DECIMAL_NUMBER: GUnicodeType = GUnicodeType::DecimalNumber;
pub const G_UNICODE_LETTER_NUMBER: GUnicodeType = GUnicodeType::LetterNumber;
pub const G_UNICODE_OTHER_NUMBER: GUnicodeType = GUnicodeType::OtherNumber;
pub const G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = GUnicodeType::ConnectPunctuation;
pub const G_UNICODE_DASH_PUNCTUATION: GUnicodeType = GUnicodeType::DashPunctuation;
pub const G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = GUnicodeType::ClosePunctuation;
pub const G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = GUnicodeType::FinalPunctuation;
pub const G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = GUnicodeType::InitialPunctuation;
pub const G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = GUnicodeType::OtherPunctuation;
pub const G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = GUnicodeType::OpenPunctuation;
pub const G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = GUnicodeType::CurrencySymbol;
pub const G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = GUnicodeType::ModifierSymbol;
pub const G_UNICODE_MATH_SYMBOL: GUnicodeType = GUnicodeType::MathSymbol;
pub const G_UNICODE_OTHER_SYMBOL: GUnicodeType = GUnicodeType::OtherSymbol;
pub const G_UNICODE_LINE_SEPARATOR: GUnicodeType = GUnicodeType::LineSeparator;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = GUnicodeType::ParagraphSeparator;
pub const G_UNICODE_SPACE_SEPARATOR: GUnicodeType = GUnicodeType::SpaceSeparator;

pub type GUnixFDSourceFunc = extern "C" fn (gint, GIOCondition, gpointer) -> gboolean;

#[repr(C)]
pub enum GUserDirectory {
    DirectoryDesktop = 0,
    DirectoryDocuments = 1,
    DirectoryDownload = 2,
    DirectoryMusic = 3,
    DirectoryPictures = 4,
    DirectoryPublicShare = 5,
    DirectoryTemplates = 6,
    DirectoryVideos = 7,
    NDirectories = 8,
}
pub const G_USER_DIRECTORY_DESKTOP: GUserDirectory = GUserDirectory::DirectoryDesktop;
pub const G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = GUserDirectory::DirectoryDocuments;
pub const G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = GUserDirectory::DirectoryDownload;
pub const G_USER_DIRECTORY_MUSIC: GUserDirectory = GUserDirectory::DirectoryMusic;
pub const G_USER_DIRECTORY_PICTURES: GUserDirectory = GUserDirectory::DirectoryPictures;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = GUserDirectory::DirectoryPublicShare;
pub const G_USER_DIRECTORY_TEMPLATES: GUserDirectory = GUserDirectory::DirectoryTemplates;
pub const G_USER_DIRECTORY_VIDEOS: GUserDirectory = GUserDirectory::DirectoryVideos;
pub const G_USER_N_DIRECTORIES: GUserDirectory = GUserDirectory::NDirectories;

pub const GLIB_VERSION_MIN_REQUIRED: gint = 2;

pub enum GVariant { }

#[repr(C)]
pub struct GVariantBuilder {
    x: [gsize; 16],
}

#[repr(C)]
pub enum GVariantClass {
    Tuple = 40,
    Array = 97,
    Boolean = 98,
    Double = 100,
    Signature = 103,
    Handle = 104,
    Int32 = 105,
    Maybe = 109,
    Int16 = 110,
    ObjectPath = 111,
    Uint16 = 113,
    String = 115,
    Uint64 = 116,
    Uint32 = 117,
    Variant = 118,
    Int64 = 120,
    Byte = 121,
    DictEntry = 123,
}
pub const G_VARIANT_CLASS_BOOLEAN: GVariantClass = GVariantClass::Boolean;
pub const G_VARIANT_CLASS_BYTE: GVariantClass = GVariantClass::Byte;
pub const G_VARIANT_CLASS_INT16: GVariantClass = GVariantClass::Int16;
pub const G_VARIANT_CLASS_UINT16: GVariantClass = GVariantClass::Uint16;
pub const G_VARIANT_CLASS_INT32: GVariantClass = GVariantClass::Int32;
pub const G_VARIANT_CLASS_UINT32: GVariantClass = GVariantClass::Uint32;
pub const G_VARIANT_CLASS_INT64: GVariantClass = GVariantClass::Int64;
pub const G_VARIANT_CLASS_UINT64: GVariantClass = GVariantClass::Uint64;
pub const G_VARIANT_CLASS_HANDLE: GVariantClass = GVariantClass::Handle;
pub const G_VARIANT_CLASS_DOUBLE: GVariantClass = GVariantClass::Double;
pub const G_VARIANT_CLASS_STRING: GVariantClass = GVariantClass::String;
pub const G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = GVariantClass::ObjectPath;
pub const G_VARIANT_CLASS_SIGNATURE: GVariantClass = GVariantClass::Signature;
pub const G_VARIANT_CLASS_VARIANT: GVariantClass = GVariantClass::Variant;
pub const G_VARIANT_CLASS_MAYBE: GVariantClass = GVariantClass::Maybe;
pub const G_VARIANT_CLASS_ARRAY: GVariantClass = GVariantClass::Array;
pub const G_VARIANT_CLASS_TUPLE: GVariantClass = GVariantClass::Tuple;
pub const G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = GVariantClass::DictEntry;

#[repr(C)]
pub struct GVariantDict {
    x: [gsize; 16],
}

#[repr(C)]
pub struct GVariantIter {
    x: [gsize; 16],
}

#[repr(C)]
pub enum GVariantParseError {
    Failed = 0,
    BasicTypeExpected = 1,
    CannotInferType = 2,
    DefiniteTypeExpected = 3,
    InputNotAtEnd = 4,
    InvalidCharacter = 5,
    InvalidFormatString = 6,
    InvalidObjectPath = 7,
    InvalidSignature = 8,
    InvalidTypeString = 9,
    NoCommonType = 10,
    NumberOutOfRange = 11,
    NumberTooBig = 12,
    TypeError = 13,
    UnexpectedToken = 14,
    UnknownKeyword = 15,
    UnterminatedStringConstant = 16,
    ValueExpected = 17,
}
pub const G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = GVariantParseError::Failed;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = GVariantParseError::BasicTypeExpected;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = GVariantParseError::CannotInferType;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = GVariantParseError::DefiniteTypeExpected;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = GVariantParseError::InputNotAtEnd;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = GVariantParseError::InvalidCharacter;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = GVariantParseError::InvalidFormatString;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = GVariantParseError::InvalidObjectPath;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = GVariantParseError::InvalidSignature;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = GVariantParseError::InvalidTypeString;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = GVariantParseError::NoCommonType;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = GVariantParseError::NumberOutOfRange;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = GVariantParseError::NumberTooBig;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = GVariantParseError::TypeError;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = GVariantParseError::UnexpectedToken;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = GVariantParseError::UnknownKeyword;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: GVariantParseError = GVariantParseError::UnterminatedStringConstant;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = GVariantParseError::ValueExpected;

pub enum GVariantType { }

pub type GVoidFunc = extern "C" fn ();

pub const G_WIN32_MSG_HANDLE: gint = 19981206;


pub const GLIB_SYSDEF_AF_INET:  gint = libc::AF_INET;
pub const GLIB_SYSDEF_AF_INET6: gint = libc::AF_INET6;
pub const GLIB_SYSDEF_AF_UNIX:  gint = libc::AF_UNIX;

mod consts {

    // The BSD definitions are used everywhere,
    // but we should keep an exhaustive list, just in case.
    #[cfg(any(target_os = "linux",
              target_os = "windows",
              target_os = "macos",
              target_os = "freebsd",
              target_os = "dragonfly",
              target_os = "openbsd",
              target_os = "bitrig",
              target_os = "netbsd",
              target_os = "android",
              target_os = "nacl"))]
    pub mod os {

        use gtypes::*;

        pub const GLIB_SYSDEF_MSG_OOB:       gint = 1;
        pub const GLIB_SYSDEF_MSG_PEEK:      gint = 2;
        pub const GLIB_SYSDEF_MSG_DONTROUTE: gint = 4;
    }

    // ILP32, standard printf format modifiers
    #[cfg(all(any(target_arch = "x86",
                  target_arch = "arm",
                  target_arch = "mips",
                  target_arch = "mipsel",
                  target_arch = "powerpc",
                  target_arch = "le32"),
              not(windows)))]
    pub mod datamodel {
        pub const G_GINT16_MODIFIER: &'static [u8] = b"h\0";
        pub const G_GINT16_FORMAT: &'static [u8] = b"hi\0";
        pub const G_GUINT16_FORMAT: &'static [u8] = b"hu\0";
        pub const G_GINT32_MODIFIER: &'static [u8] = b"\0";
        pub const G_GINT32_FORMAT: &'static [u8] = b"i\0";
        pub const G_GUINT32_FORMAT: &'static [u8] = b"u\0";
        pub const G_GINT64_MODIFIER: &'static [u8] = b"ll\0";
        pub const G_GINT64_FORMAT: &'static [u8] = b"lli\0";
        pub const G_GUINT64_FORMAT: &'static [u8] = b"llu\0";
        pub const G_GINTPTR_MODIFIER: &'static [u8] = b"\0";
        pub const G_GINTPTR_FORMAT: &'static [u8] = b"i\0";
        pub const G_GUINTPTR_FORMAT: &'static [u8] = b"u\0";
        pub const G_GSIZE_MODIFIER: &'static [u8] = b"\0";
        pub const G_GSSIZE_MODIFIER: &'static [u8] = b"\0";
        pub const G_GSIZE_FORMAT: &'static [u8] = b"u\0";
        pub const G_GSSIZE_FORMAT: &'static [u8] = b"i\0";
    }

    // On Win32, GLib uses MSVCRT-specific format modifiers for 64-bit types
    #[cfg(all(windows, target_arch = "x86"))]
    pub mod datamodel {
        pub const G_GINT16_MODIFIER: &'static [u8] = b"h\0";
        pub const G_GINT16_FORMAT: &'static [u8] = b"hi\0";
        pub const G_GUINT16_FORMAT: &'static [u8] = b"hu\0";
        pub const G_GINT32_MODIFIER: &'static [u8] = b"\0";
        pub const G_GINT32_FORMAT: &'static [u8] = b"i\0";
        pub const G_GUINT32_FORMAT: &'static [u8] = b"u\0";
        pub const G_GINT64_MODIFIER: &'static [u8] = b"I64\0";
        pub const G_GINT64_FORMAT: &'static [u8] = b"I64i\0";
        pub const G_GUINT64_FORMAT: &'static [u8] = b"I64u\0";
        pub const G_GINTPTR_MODIFIER: &'static [u8] = b"\0";
        pub const G_GINTPTR_FORMAT: &'static [u8] = b"i\0";
        pub const G_GUINTPTR_FORMAT: &'static [u8] = b"u\0";
        pub const G_GSIZE_MODIFIER: &'static [u8] = b"\0";
        pub const G_GSSIZE_MODIFIER: &'static [u8] = b"\0";
        pub const G_GSIZE_FORMAT: &'static [u8] = b"u\0";
        pub const G_GSSIZE_FORMAT: &'static [u8] = b"i\0";
    }

    // LP64
    #[cfg(all(unix,
              any(target_arch = "x86_64",
                  target_arch = "aarch64")))]
    pub mod datamodel {
        pub const G_GINT16_MODIFIER: &'static [u8] = b"h\0";
        pub const G_GINT16_FORMAT: &'static [u8] = b"hi\0";
        pub const G_GUINT16_FORMAT: &'static [u8] = b"hu\0";
        pub const G_GINT32_MODIFIER: &'static [u8] = b"\0";
        pub const G_GINT32_FORMAT: &'static [u8] = b"i\0";
        pub const G_GUINT32_FORMAT: &'static [u8] = b"u\0";
        pub const G_GINT64_MODIFIER: &'static [u8] = b"l\0";
        pub const G_GINT64_FORMAT: &'static [u8] = b"li\0";
        pub const G_GUINT64_FORMAT: &'static [u8] = b"lu\0";
        pub const G_GINTPTR_MODIFIER: &'static [u8] = b"l\0";
        pub const G_GINTPTR_FORMAT: &'static [u8] = b"li\0";
        pub const G_GUINTPTR_FORMAT: &'static [u8] = b"lu\0";
        pub const G_GSIZE_MODIFIER: &'static [u8] = b"l\0";
        pub const G_GSSIZE_MODIFIER: &'static [u8] = b"l\0";
        pub const G_GSIZE_FORMAT: &'static [u8] = b"lu\0";
        pub const G_GSSIZE_FORMAT: &'static [u8] = b"li\0";
    }

    // 64-bit Windows
    #[cfg(all(windows, target_arch = "x86_64"))]
    pub mod datamodel {
        pub const G_GINT16_MODIFIER: &'static [u8] = b"h\0";
        pub const G_GINT16_FORMAT: &'static [u8] = b"hi\0";
        pub const G_GUINT16_FORMAT: &'static [u8] = b"hu\0";
        pub const G_GINT32_MODIFIER: &'static [u8] = b"\0";
        pub const G_GINT32_FORMAT: &'static [u8] = b"i\0";
        pub const G_GUINT32_FORMAT: &'static [u8] = b"u\0";
        pub const G_GINT64_MODIFIER: &'static [u8] = b"I64\0";
        pub const G_GINT64_FORMAT: &'static [u8] = b"I64i\0";
        pub const G_GUINT64_FORMAT: &'static [u8] = b"I64u\0";
        pub const G_GINTPTR_MODIFIER: &'static [u8] = b"I64\0";
        pub const G_GINTPTR_FORMAT: &'static [u8] = b"I64i\0";
        pub const G_GUINTPTR_FORMAT: &'static [u8] = b"I64u\0";
        pub const G_GSIZE_MODIFIER: &'static [u8] = b"I64\0";
        pub const G_GSSIZE_MODIFIER: &'static [u8] = b"I64\0";
        pub const G_GSIZE_FORMAT: &'static [u8] = b"I64u\0";
        pub const G_GSSIZE_FORMAT: &'static [u8] = b"I64i\0";
    }

    #[cfg(unix)]
    pub mod filename {
        pub const G_DIR_SEPARATOR: u8 = b'/';
        pub const G_DIR_SEPARATOR_S: &'static [u8] = b"/\0";
        pub const G_SEARCHPATH_SEPARATOR: u8 = b':';
        pub const G_SEARCHPATH_SEPARATOR_S: &'static [u8] = b":\0";
        pub const G_MODULE_SUFFIX: &'static [u8] = b"so\0";
    }

    #[cfg(windows)]
    pub mod filename {
        pub const G_DIR_SEPARATOR: u8 = b'\\';
        pub const G_DIR_SEPARATOR_S: &'static [u8] = b"\\\0";
        pub const G_SEARCHPATH_SEPARATOR: u8 = b';';
        pub const G_SEARCHPATH_SEPARATOR_S: &'static [u8] = b";\0";
        pub const G_MODULE_SUFFIX: &'static [u8] = b"dll\0";
    }

    #[cfg(unix)]
    pub mod pollfd {
        pub const G_POLLFD_FORMAT: &'static [u8] = b"%d\0";
    }

    #[cfg(windows)]
    pub mod pollfd {

        #[cfg(target_arch = "x86")]
        pub const G_POLLFD_FORMAT: &'static [u8] = b"%#x\0";

        #[cfg(target_arch = "x86_64")]
        pub const G_POLLFD_FORMAT: &'static [u8] = b"%#I64x\0";
    }
}

pub use consts::os::*;
pub use consts::datamodel::*;
pub use consts::filename::*;
pub use consts::pollfd::*;

extern {
    pub fn g_access(filename: *const gchar, mode: gint) -> gint;
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
    pub fn g_array_insert_vals(array: *mut GArray, index_: guint, data: gconstpointer, len: guint) -> *mut GArray;
    pub fn g_array_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint) -> *mut GArray;
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
    pub fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint, reserved_size: guint) -> *mut GArray;
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
    pub fn g_array_sort_with_data(array: *mut GArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_array_unref(array: *mut GArray);
    pub fn g_ascii_digit_value(c: gchar) -> gint;
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
    pub fn g_ascii_formatd(buffer: *mut gchar, buf_len: gint, format: *const gchar, d: gdouble) -> *mut gchar;
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_ascii_strdown(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut gchar) -> gdouble;
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut gchar, base: guint) -> i64;
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut gchar, base: guint) -> u64;
    pub fn g_ascii_strup(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_ascii_tolower(c: gchar) -> gchar;
    pub fn g_ascii_toupper(c: gchar) -> gchar;
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
    pub fn g_assert_warning(log_domain: *const gchar, file: *const gchar, line: gint, pretty_function: *const gchar, expression: *const gchar);
    pub fn g_assertion_message(domain: *const gchar, file: *const gchar, line: gint, func: *const gchar, message: *const gchar);
    pub fn g_assertion_message_cmpstr(domain: *const gchar, file: *const gchar, line: gint, func: *const gchar, expr: *const gchar, arg1: *const gchar, cmp: *const gchar, arg2: *const gchar);
    pub fn g_assertion_message_error(domain: *const gchar, file: *const gchar, line: gint, func: *const gchar, expr: *const gchar, error: *const GError, error_domain: GQuark, error_code: gint);
    pub fn g_assertion_message_expr(domain: *const gchar, file: *const gchar, line: gint, func: *const gchar, expr: *const gchar);
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_sorted(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_push_sorted_unlocked(queue: *mut GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_sort_unlocked(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timed_pop_unlocked(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_timeout_pop_unlocked(queue: *mut GAsyncQueue, timeout: u64) -> gpointer;
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
    pub fn g_atexit(func: GVoidFunc);
    pub fn g_atomic_int_add(atomic: gint, val: gint) -> gint;
    pub fn g_atomic_int_and(atomic: guint, val: guint) -> guint;
    pub fn g_atomic_int_compare_and_exchange(atomic: gint, oldval: gint, newval: gint) -> gboolean;
    pub fn g_atomic_int_dec_and_test(atomic: gint) -> gboolean;
    pub fn g_atomic_int_exchange_and_add(atomic: gint, val: gint) -> gint;
    pub fn g_atomic_int_get(atomic: gint) -> gint;
    pub fn g_atomic_int_inc(atomic: gint);
    pub fn g_atomic_int_or(atomic: guint, val: guint) -> guint;
    pub fn g_atomic_int_set(atomic: gint, newval: gint);
    pub fn g_atomic_int_xor(atomic: guint, val: guint) -> guint;
    pub fn g_atomic_pointer_add(atomic: gpointer, val: gssize) -> gssize;
    pub fn g_atomic_pointer_and(atomic: gpointer, val: gsize) -> gsize;
    pub fn g_atomic_pointer_compare_and_exchange(atomic: gpointer, oldval: gpointer, newval: gpointer) -> gboolean;
    pub fn g_atomic_pointer_get(atomic: gpointer) -> gpointer;
    pub fn g_atomic_pointer_or(atomic: gpointer, val: gsize) -> gsize;
    pub fn g_atomic_pointer_set(atomic: gpointer, newval: gpointer);
    pub fn g_atomic_pointer_xor(atomic: gpointer, val: gsize) -> gsize;
    pub fn g_base64_decode(text: *const gchar, out_len: gsize) -> *mut u8;
    pub fn g_base64_decode_inplace(text: gchar, out_len: gsize) -> u8;
    pub fn g_base64_decode_step(in_: *mut gchar, len: gsize, out: *mut u8, state: gint, save: guint) -> gsize;
    pub fn g_base64_encode(data: *mut u8, len: gsize) -> *mut gchar;
    pub fn g_base64_encode_close(break_lines: gboolean, out: gchar, state: gint, save: gint) -> gsize;
    pub fn g_base64_encode_step(in_: *mut u8, len: gsize, break_lines: gboolean, out: gchar, state: gint, save: gint) -> gsize;
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
    pub fn g_bit_lock(address: gint, lock_bit: gint);
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
    pub fn g_bit_storage(number: gulong) -> guint;
    pub fn g_bit_trylock(address: gint, lock_bit: gint) -> gboolean;
    pub fn g_bit_unlock(address: gint, lock_bit: gint);
    pub fn g_bookmark_file_add_application(bookmark: *mut GBookmarkFile, uri: *const gchar, name: *const gchar, exec: *const gchar);
    pub fn g_bookmark_file_add_group(bookmark: *mut GBookmarkFile, uri: *const gchar, group: *const gchar);
    pub fn g_bookmark_file_error_quark() -> GQuark;
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
    pub fn g_bookmark_file_get_added(bookmark: *mut GBookmarkFile, uri: *const gchar) -> libc::time_t;
    pub fn g_bookmark_file_get_app_info(bookmark: *mut GBookmarkFile, uri: *const gchar, name: *const gchar, exec: *mut gchar, count: guint, stamp: libc::time_t) -> gboolean;
    pub fn g_bookmark_file_get_applications(bookmark: *mut GBookmarkFile, uri: *const gchar, length: gsize) -> *mut *mut gchar;
    pub fn g_bookmark_file_get_description(bookmark: *mut GBookmarkFile, uri: *const gchar) -> *mut gchar;
    pub fn g_bookmark_file_get_groups(bookmark: *mut GBookmarkFile, uri: *const gchar, length: gsize) -> *mut *mut gchar;
    pub fn g_bookmark_file_get_icon(bookmark: *mut GBookmarkFile, uri: *const gchar, href: *mut gchar, mime_type: *mut gchar) -> gboolean;
    pub fn g_bookmark_file_get_is_private(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
    pub fn g_bookmark_file_get_mime_type(bookmark: *mut GBookmarkFile, uri: *const gchar) -> *mut gchar;
    pub fn g_bookmark_file_get_modified(bookmark: *mut GBookmarkFile, uri: *const gchar) -> libc::time_t;
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
    pub fn g_bookmark_file_get_title(bookmark: *mut GBookmarkFile, uri: *const gchar) -> *mut gchar;
    pub fn g_bookmark_file_get_uris(bookmark: *mut GBookmarkFile, length: gsize) -> *mut *mut gchar;
    pub fn g_bookmark_file_get_visited(bookmark: *mut GBookmarkFile, uri: *const gchar) -> libc::time_t;
    pub fn g_bookmark_file_has_application(bookmark: *mut GBookmarkFile, uri: *const gchar, name: *const gchar) -> gboolean;
    pub fn g_bookmark_file_has_group(bookmark: *mut GBookmarkFile, uri: *const gchar, group: *const gchar) -> gboolean;
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
    pub fn g_bookmark_file_load_from_data(bookmark: *mut GBookmarkFile, data: *const gchar, length: gsize) -> gboolean;
    pub fn g_bookmark_file_load_from_data_dirs(bookmark: *mut GBookmarkFile, file: *const gchar, full_path: *mut *mut gchar) -> gboolean;
    pub fn g_bookmark_file_load_from_file(bookmark: *mut GBookmarkFile, filename: *const gchar) -> gboolean;
    pub fn g_bookmark_file_move_item(bookmark: *mut GBookmarkFile, old_uri: *const gchar, new_uri: *const gchar) -> gboolean;
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
    pub fn g_bookmark_file_remove_application(bookmark: *mut GBookmarkFile, uri: *const gchar, name: *const gchar) -> gboolean;
    pub fn g_bookmark_file_remove_group(bookmark: *mut GBookmarkFile, uri: *const gchar, group: *const gchar) -> gboolean;
    pub fn g_bookmark_file_remove_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
    pub fn g_bookmark_file_set_added(bookmark: *mut GBookmarkFile, uri: *const gchar, added: libc::time_t);
    pub fn g_bookmark_file_set_app_info(bookmark: *mut GBookmarkFile, uri: *const gchar, name: *const gchar, exec: *const gchar, count: gint, stamp: libc::time_t) -> gboolean;
    pub fn g_bookmark_file_set_description(bookmark: *mut GBookmarkFile, uri: *const gchar, description: *const gchar);
    pub fn g_bookmark_file_set_groups(bookmark: *mut GBookmarkFile, uri: *const gchar, groups: *mut *const gchar, length: gsize);
    pub fn g_bookmark_file_set_icon(bookmark: *mut GBookmarkFile, uri: *const gchar, href: *const gchar, mime_type: *const gchar);
    pub fn g_bookmark_file_set_is_private(bookmark: *mut GBookmarkFile, uri: *const gchar, is_private: gboolean);
    pub fn g_bookmark_file_set_mime_type(bookmark: *mut GBookmarkFile, uri: *const gchar, mime_type: *const gchar);
    pub fn g_bookmark_file_set_modified(bookmark: *mut GBookmarkFile, uri: *const gchar, modified: libc::time_t);
    pub fn g_bookmark_file_set_title(bookmark: *mut GBookmarkFile, uri: *const gchar, title: *const gchar);
    pub fn g_bookmark_file_set_visited(bookmark: *mut GBookmarkFile, uri: *const gchar, visited: libc::time_t);
    pub fn g_bookmark_file_to_data(bookmark: *mut GBookmarkFile, length: gsize) -> *mut gchar;
    pub fn g_bookmark_file_to_file(bookmark: *mut GBookmarkFile, filename: *const gchar) -> gboolean;
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
    pub fn g_byte_array_append(array: *mut GByteArray, data: u8, len: guint) -> *mut GByteArray;
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> u8;
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
    pub fn g_byte_array_new() -> *mut GByteArray;
    pub fn g_byte_array_new_take(data: *mut u8, len: gsize) -> *mut GByteArray;
    pub fn g_byte_array_prepend(array: *mut GByteArray, data: u8, len: guint) -> *mut GByteArray;
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
    pub fn g_byte_array_remove_range(array: *mut GByteArray, index_: guint, length: guint) -> *mut GByteArray;
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
    pub fn g_byte_array_sort_with_data(array: *mut GByteArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_byte_array_unref(array: *mut GByteArray);
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: gsize) -> gconstpointer;
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_with_free_func(data: gconstpointer, size: gsize, free_func: GDestroyNotify, user_data: gpointer) -> *mut GBytes;
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
    pub fn g_bytes_unref(bytes: *mut GBytes);
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: gsize) -> gpointer;
    pub fn g_chdir(path: *const gchar) -> gint;
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
    pub fn g_checksum_free(checksum: *mut GChecksum);
    pub fn g_checksum_get_digest(checksum: *mut GChecksum, buffer: u8, digest_len: gsize);
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
    pub fn g_checksum_reset(checksum: *mut GChecksum);
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *mut u8, length: gssize);
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
    pub fn g_child_watch_add_full(priority: gint, pid: GPid, function: GChildWatchFunc, data: gpointer, notify: Option<GDestroyNotify>) -> guint;
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
    pub fn g_clear_error();
    pub fn g_clear_pointer(pp: gpointer, destroy: GDestroyNotify);
    pub fn g_close(fd: gint) -> gboolean;
    pub fn g_compute_checksum_for_bytes(checksum_type: GChecksumType, data: *mut GBytes) -> *mut gchar;
    pub fn g_compute_checksum_for_data(checksum_type: GChecksumType, data: *mut u8, length: gsize) -> *mut gchar;
    pub fn g_compute_checksum_for_string(checksum_type: GChecksumType, str: *const gchar, length: gssize) -> *mut gchar;
    pub fn g_compute_hmac_for_data(digest_type: GChecksumType, key: *mut u8, key_len: gsize, data: u8, length: gsize) -> *mut gchar;
    pub fn g_compute_hmac_for_string(digest_type: GChecksumType, key: *mut u8, key_len: gsize, str: *const gchar, length: gssize) -> *mut gchar;
    pub fn g_cond_broadcast(cond: *mut GCond);
    pub fn g_cond_clear(cond: *mut GCond);
    pub fn g_cond_init(cond: *mut GCond);
    pub fn g_cond_signal(cond: *mut GCond);
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: i64) -> gboolean;
    pub fn g_convert(str: *const gchar, len: gssize, to_codeset: *const gchar, from_codeset: *const gchar, bytes_read: gsize, bytes_written: gsize) -> *mut gchar;
    pub fn g_convert_error_quark() -> GQuark;
    pub fn g_convert_with_fallback(str: *const gchar, len: gssize, to_codeset: *const gchar, from_codeset: *const gchar, fallback: *const gchar, bytes_read: gsize, bytes_written: gsize) -> *mut gchar;
    pub fn g_convert_with_iconv(str: *const gchar, len: gssize, converter: GIConv, bytes_read: gsize, bytes_written: gsize) -> *mut gchar;
    pub fn g_datalist_clear(datalist: *mut *mut GData);
    pub fn g_datalist_foreach(datalist: *mut *mut GData, func: GDataForeachFunc, user_data: gpointer);
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
    pub fn g_datalist_id_dup_data(datalist: *mut *mut GData, key_id: GQuark, dup_func: Option<GDuplicateFunc>, user_data: gpointer) -> gpointer;
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    pub fn g_datalist_id_replace_data(datalist: *mut *mut GData, key_id: GQuark, oldval: gpointer, newval: gpointer, destroy: Option<GDestroyNotify>, old_destroy: GDestroyNotify) -> gboolean;
    pub fn g_datalist_id_set_data_full(datalist: *mut *mut GData, key_id: GQuark, data: gpointer, destroy_func: Option<GDestroyNotify>);
    pub fn g_datalist_init(datalist: *mut *mut GData);
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
    pub fn g_dataset_foreach(dataset_location: gconstpointer, func: GDataForeachFunc, user_data: gpointer);
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_dataset_id_set_data_full(dataset_location: gconstpointer, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify);
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
    pub fn g_date_free(date: *mut GDate);
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> u8;
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_julian(date: *const GDate) -> u32;
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> u8;
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> u8;
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
    pub fn g_date_new() -> *mut GDate;
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
    pub fn g_date_new_julian(julian_day: u32) -> *mut GDate;
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
    pub fn g_date_set_julian(date: *mut GDate, julian_date: u32);
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
    pub fn g_date_set_parse(date: *mut GDate, str: *const gchar);
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
    pub fn g_date_set_time_t(date: *mut GDate, timet: libc::time_t);
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
    pub fn g_date_strftime(s: *mut gchar, slen: gsize, format: *const gchar, date: *const GDate) -> gsize;
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
    pub fn g_date_time_add_full(datetime: *mut GDateTime, years: gint, months: gint, days: gint, hours: gint, minutes: gint, seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_ymd(datetime: *mut GDateTime, year: gint, month: gint, day: gint);
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
    pub fn g_date_time_new(tz: *mut GTimeZone, year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_local(t: i64) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_utc(t: i64) -> *mut GDateTime;
    pub fn g_date_time_new_local(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
    pub fn g_date_time_new_utc(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> i64;
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_unref(datetime: *mut GDateTime);
    pub fn g_date_to_struct_tm(date: *const GDate, tm: gpointer);
    pub fn g_date_valid(date: *const GDate) -> gboolean;
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
    pub fn g_date_valid_julian(julian_date: u32) -> gboolean;
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
    pub fn g_dir_close(dir: *mut GDir);
    pub fn g_dir_make_tmp(tmpl: *mut gchar) -> *mut gchar;
    pub fn g_dir_open(path: *const gchar, flags: guint) -> *mut GDir;
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
    pub fn g_dir_rewind(dir: *mut GDir);
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_direct_hash(v: gconstpointer) -> guint;
    pub fn g_dngettext(domain: *const gchar, msgid: *const gchar, msgid_plural: *const gchar, n: gulong) -> *const gchar;
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_double_hash(v: gconstpointer) -> guint;
    pub fn g_dpgettext(domain: *const gchar, msgctxtid: *const gchar, msgidoffset: gsize) -> *const gchar;
    pub fn g_dpgettext2(domain: *const gchar, context: *const gchar, msgid: *const gchar) -> *const gchar;
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
    pub fn g_environ_setenv(envp: *mut *mut gchar, variable: *const gchar, value: *const gchar, overwrite: gboolean) -> *mut *mut gchar;
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
    pub fn g_error_copy(error: *const GError) -> *mut GError;
    pub fn g_error_free(error: *mut GError);
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
    pub fn g_file_error_quark() -> GQuark;
    pub fn g_file_get_contents(filename: *mut gchar, contents: *mut gchar, length: gsize) -> gboolean;
    pub fn g_file_open_tmp(tmpl: *mut gchar, name_used: *mut gchar) -> gint;
    pub fn g_file_read_link(filename: *const gchar) -> *mut gchar;
    pub fn g_file_set_contents(filename: *mut gchar, contents: *mut gchar, length: gssize) -> gboolean;
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
    pub fn g_filename_from_uri(uri: *const gchar, hostname: *mut gchar) -> *mut gchar;
    pub fn g_filename_from_utf8(utf8string: *const gchar, len: gssize, bytes_read: gsize, bytes_written: gsize) -> *mut gchar;
    pub fn g_filename_to_uri(filename: *const gchar, hostname: *const gchar) -> *mut gchar;
    pub fn g_filename_to_utf8(opsysstring: *const gchar, len: gssize, bytes_read: gsize, bytes_written: gsize) -> *mut gchar;
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
    pub fn g_format_size(size: u64) -> *mut gchar;
    pub fn g_format_size_for_display(size: i64) -> *mut gchar;
    pub fn g_format_size_full(size: u64, flags: GFormatSizeFlags) -> *mut gchar;
    pub fn g_fprintf(file: gpointer, format: *mut gchar, ...) -> gint;
    pub fn g_free(mem: gpointer);
    pub fn g_get_application_name() -> *const gchar;
    pub fn g_get_charset(charset: *const gchar) -> gboolean;
    pub fn g_get_codeset() -> *mut gchar;
    pub fn g_get_current_dir() -> *mut gchar;
    pub fn g_get_current_time(result: *mut GTimeVal);
    pub fn g_get_environ() -> *mut *mut gchar;
    pub fn g_get_filename_charsets(charsets: *mut gchar) -> gboolean;
    pub fn g_get_home_dir() -> *const gchar;
    pub fn g_get_host_name() -> *const gchar;
    pub fn g_get_language_names() -> *mut *mut gchar;
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
    pub fn g_get_monotonic_time() -> i64;
    pub fn g_get_num_processors() -> guint;
    pub fn g_get_prgname() -> *const gchar;
    pub fn g_get_real_name() -> *const gchar;
    pub fn g_get_real_time() -> i64;
    pub fn g_get_system_config_dirs() -> *mut *mut gchar;
    pub fn g_get_system_data_dirs() -> *mut *mut gchar;
    pub fn g_get_tmp_dir() -> *const gchar;
    pub fn g_get_user_cache_dir() -> *const gchar;
    pub fn g_get_user_config_dir() -> *const gchar;
    pub fn g_get_user_data_dir() -> *const gchar;
    pub fn g_get_user_name() -> *const gchar;
    pub fn g_get_user_runtime_dir() -> *const gchar;
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
    pub fn g_hash_table_find(hash_table: *mut GHashTable, predicate: GHRFunc, user_data: gpointer) -> gpointer;
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
    pub fn g_hash_table_foreach_remove(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> guint;
    pub fn g_hash_table_foreach_steal(hash_table: *mut GHashTable, func: GHRFunc, user_data: gpointer) -> guint;
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_keys_as_array(hash_table: *mut GHashTable, length: guint) -> *mut gpointer;
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_insert(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
    pub fn g_hash_table_iter_next(iter: *mut GHashTableIter, key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
    pub fn g_hash_table_lookup_extended(hash_table: *mut GHashTable, lookup_key: gconstpointer, orig_key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
    pub fn g_hash_table_new_full(hash_func: GHashFunc, key_equal_func: GEqualFunc, key_destroy_func: Option<GDestroyNotify>, value_destroy_func: Option<GDestroyNotify>) -> *mut GHashTable;
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_replace(hash_table: *mut GHashTable, key: gpointer, value: gpointer) -> gboolean;
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: u8, digest_len: gsize);
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
    pub fn g_hmac_new(digest_type: GChecksumType, key: *mut u8, key_len: gsize) -> *mut GHmac;
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
    pub fn g_hmac_unref(hmac: *mut GHmac);
    pub fn g_hmac_update(hmac: *mut GHmac, data: *mut u8, length: gssize);
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_find(hook_list: *mut GHookList, need_valids: gboolean, func: GHookFindFunc, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_data(hook_list: *mut GHookList, need_valids: gboolean, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_func(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer) -> *mut GHook;
    pub fn g_hook_find_func_data(hook_list: *mut GHookList, need_valids: gboolean, func: gpointer, data: gpointer) -> *mut GHook;
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
    pub fn g_hook_insert_sorted(hook_list: *mut GHookList, hook: *mut GHook, func: GHookCompareFunc);
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_marshal(hook_list: *mut GHookList, may_recurse: gboolean, marshaller: GHookMarshaller, marshal_data: gpointer);
    pub fn g_hook_list_marshal_check(hook_list: *mut GHookList, may_recurse: gboolean, marshaller: GHookCheckMarshaller, marshal_data: gpointer);
    pub fn g_hook_next_valid(hook_list: *mut GHookList, hook: *mut GHook, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
    pub fn g_iconv(converter: GIConv, inbuf: *mut *mut gchar, inbytes_left: gsize, outbuf: *mut *mut gchar, outbytes_left: gsize) -> gsize;
    pub fn g_iconv_close(converter: GIConv) -> gint;
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_idle_add_full(priority: gint, function: GSourceFunc, data: gpointer, notify: Option<GDestroyNotify>) -> guint;
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
    pub fn g_idle_source_new() -> *mut GSource;
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int64_hash(v: gconstpointer) -> guint;
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int_hash(v: gconstpointer) -> guint;
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
    pub fn g_io_add_watch(channel: *mut GIOChannel, condition: GIOCondition, func: GIOFunc, user_data: gpointer) -> guint;
    pub fn g_io_add_watch_full(channel: *mut GIOChannel, priority: gint, condition: GIOCondition, func: GIOFunc, user_data: gpointer, notify: GDestroyNotify) -> guint;
    pub fn g_io_channel_close(channel: *mut GIOChannel);
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
    pub fn g_io_channel_error_quark() -> GQuark;
    pub fn g_io_channel_flush(channel: *mut GIOChannel) -> GIOStatus;
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: gint) -> *const gchar;
    pub fn g_io_channel_init(channel: *mut GIOChannel);
    pub fn g_io_channel_new_file(filename: *const gchar, mode: *const gchar) -> *mut GIOChannel;
    pub fn g_io_channel_read(channel: *mut GIOChannel, buf: *mut gchar, count: gsize, bytes_read: gsize) -> GIOError;
    pub fn g_io_channel_read_chars(channel: *mut GIOChannel, buf: *mut gchar, count: gsize, bytes_read: gsize) -> GIOStatus;
    pub fn g_io_channel_read_line(channel: *mut GIOChannel, str_return: *mut gchar, length: gsize, terminator_pos: gsize) -> GIOStatus;
    pub fn g_io_channel_read_line_string(channel: *mut GIOChannel, buffer: *mut GString, terminator_pos: gsize) -> GIOStatus;
    pub fn g_io_channel_read_to_end(channel: *mut GIOChannel, str_return: *mut gchar, length: gsize) -> GIOStatus;
    pub fn g_io_channel_read_unichar(channel: *mut GIOChannel, thechar: gunichar) -> GIOStatus;
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
    pub fn g_io_channel_seek(channel: *mut GIOChannel, offset: i64, type_: GSeekType) -> GIOError;
    pub fn g_io_channel_seek_position(channel: *mut GIOChannel, offset: i64, type_: GSeekType) -> GIOStatus;
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
    pub fn g_io_channel_set_encoding(channel: *mut GIOChannel, encoding: *const gchar) -> GIOStatus;
    pub fn g_io_channel_set_flags(channel: *mut GIOChannel, flags: GIOFlags) -> GIOStatus;
    pub fn g_io_channel_set_line_term(channel: *mut GIOChannel, line_term: *const gchar, length: gint);
    pub fn g_io_channel_shutdown(channel: *mut GIOChannel, flush: gboolean) -> GIOStatus;
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
    pub fn g_io_channel_unix_new(fd: gint) -> *mut GIOChannel;
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
    pub fn g_io_channel_write(channel: *mut GIOChannel, buf: *const gchar, count: gsize, bytes_written: gsize) -> GIOError;
    pub fn g_io_channel_write_chars(channel: *mut GIOChannel, buf: *mut gchar, count: gssize, bytes_written: gsize) -> GIOStatus;
    pub fn g_io_channel_write_unichar(channel: *mut GIOChannel, thechar: gunichar) -> GIOStatus;
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
    pub fn g_key_file_error_quark() -> GQuark;
    pub fn g_key_file_free(key_file: *mut GKeyFile);
    pub fn g_key_file_get_boolean(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> gboolean;
    pub fn g_key_file_get_boolean_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, length: gsize) -> *mut gboolean;
    pub fn g_key_file_get_comment(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> *mut gchar;
    pub fn g_key_file_get_double(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> gdouble;
    pub fn g_key_file_get_double_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, length: gsize) -> *mut gdouble;
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: gsize) -> *mut *mut gchar;
    pub fn g_key_file_get_int64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> i64;
    pub fn g_key_file_get_integer(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> gint;
    pub fn g_key_file_get_integer_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, length: gsize) -> *mut gint;
    pub fn g_key_file_get_keys(key_file: *mut GKeyFile, group_name: *const gchar, length: gsize) -> *mut *mut gchar;
    pub fn g_key_file_get_locale_string(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, locale: *const gchar) -> *mut gchar;
    pub fn g_key_file_get_locale_string_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, locale: *const gchar, length: gsize) -> *mut *mut gchar;
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
    pub fn g_key_file_get_string(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> *mut gchar;
    pub fn g_key_file_get_string_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, length: gsize) -> *mut *mut gchar;
    pub fn g_key_file_get_uint64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> u64;
    pub fn g_key_file_get_value(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> *mut gchar;
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
    pub fn g_key_file_has_key(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> gboolean;
    pub fn g_key_file_load_from_data(key_file: *mut GKeyFile, data: *const gchar, length: gsize, flags: GKeyFileFlags) -> gboolean;
    pub fn g_key_file_load_from_data_dirs(key_file: *mut GKeyFile, file: *mut gchar, full_path: *mut gchar, flags: GKeyFileFlags) -> gboolean;
    pub fn g_key_file_load_from_dirs(key_file: *mut GKeyFile, file: *mut gchar, search_dirs: *mut *mut gchar, full_path: *mut gchar, flags: GKeyFileFlags) -> gboolean;
    pub fn g_key_file_load_from_file(key_file: *mut GKeyFile, file: *mut gchar, flags: GKeyFileFlags) -> gboolean;
    pub fn g_key_file_new() -> *mut GKeyFile;
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
    pub fn g_key_file_remove_comment(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> gboolean;
    pub fn g_key_file_remove_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
    pub fn g_key_file_remove_key(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar) -> gboolean;
    pub fn g_key_file_save_to_file(key_file: *mut GKeyFile, filename: *const gchar) -> gboolean;
    pub fn g_key_file_set_boolean(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: gboolean);
    pub fn g_key_file_set_boolean_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, list: gboolean, length: gsize);
    pub fn g_key_file_set_comment(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, comment: *const gchar) -> gboolean;
    pub fn g_key_file_set_double(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: gdouble);
    pub fn g_key_file_set_double_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, list: gdouble, length: gsize);
    pub fn g_key_file_set_int64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: i64);
    pub fn g_key_file_set_integer(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: gint);
    pub fn g_key_file_set_integer_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, list: gint, length: gsize);
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
    pub fn g_key_file_set_locale_string(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, locale: *const gchar, string: *const gchar);
    pub fn g_key_file_set_locale_string_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, locale: *const gchar, list: *mut gchar, length: gsize);
    pub fn g_key_file_set_string(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, string: *const gchar);
    pub fn g_key_file_set_string_list(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, list: *mut gchar, length: gsize);
    pub fn g_key_file_set_uint64(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: u64);
    pub fn g_key_file_set_value(key_file: *mut GKeyFile, group_name: *const gchar, key: *const gchar, value: *const gchar);
    pub fn g_key_file_to_data(key_file: *mut GKeyFile, length: gsize) -> *mut gchar;
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
    pub fn g_list_alloc() -> *mut GList;
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_find_custom(list: *mut GList, data: gconstpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_list_first(list: *mut GList) -> *mut GList;
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
    pub fn g_list_free(list: *mut GList);
    pub fn g_list_free_1(list: *mut GList);
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
    pub fn g_list_insert_before(list: *mut GList, sibling: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_list_insert_sorted_with_data(list: *mut GList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_last(list: *mut GList) -> *mut GList;
    pub fn g_list_length(list: *mut GList) -> guint;
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
    pub fn g_list_sort_with_data(list: *mut GList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GList;
    pub fn g_listenv() -> *mut *mut gchar;
    pub fn g_locale_from_utf8(utf8string: *const gchar, len: gssize, bytes_read: gsize, bytes_written: gsize) -> *mut gchar;
    pub fn g_locale_to_utf8(opsysstring: *const gchar, len: gssize, bytes_read: gsize, bytes_written: gsize) -> *mut gchar;
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
    pub fn g_log_default_handler(log_domain: *const gchar, log_level: GLogLevelFlags, message: *const gchar, unused_data: gpointer);
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
    pub fn g_log_set_fatal_mask(log_domain: *const gchar, fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_handler(log_domain: *const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer) -> guint;
    pub fn g_log_set_handler_full(log_domain: *const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer, destroy: GDestroyNotify) -> guint;
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
    pub fn g_main_context_check(context: *mut GMainContext, max_priority: gint, fds: *mut GPollFD, n_fds: gint) -> gint;
    pub fn g_main_context_default() -> *mut GMainContext;
    pub fn g_main_context_dispatch(context: *mut GMainContext);
    pub fn g_main_context_find_source_by_funcs_user_data(context: *mut GMainContext, funcs: *mut GSourceFuncs, user_data: gpointer) -> *mut GSource;
    pub fn g_main_context_find_source_by_id(context: *mut GMainContext, source_id: guint) -> *mut GSource;
    pub fn g_main_context_find_source_by_user_data(context: *mut GMainContext, user_data: gpointer) -> *mut GSource;
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
    pub fn g_main_context_invoke_full(context: *mut GMainContext, priority: gint, function: GSourceFunc, data: gpointer, notify: Option<GDestroyNotify>);
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
    pub fn g_main_context_new() -> *mut GMainContext;
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: gint) -> gboolean;
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
    pub fn g_main_context_query(context: *mut GMainContext, max_priority: gint, timeout_: gint, fds: *mut GPollFD, n_fds: gint) -> gint;
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
    pub fn g_main_context_release(context: *mut GMainContext);
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
    pub fn g_main_context_unref(context: *mut GMainContext);
    pub fn g_main_context_wait(context: *mut GMainContext, cond: *mut GCond, mutex: *mut GMutex) -> gboolean;
    pub fn g_main_context_wakeup(context: *mut GMainContext);
    pub fn g_main_current_source() -> *mut GSource;
    pub fn g_main_depth() -> gint;
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_mapped_file_free(file: *mut GMappedFile);
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
    pub fn g_mapped_file_new(filename: *const gchar, writable: gboolean) -> *mut GMappedFile;
    pub fn g_mapped_file_new_from_fd(fd: gint, writable: gboolean) -> *mut GMappedFile;
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
    pub fn g_markup_collect_attributes(element_name: *const gchar, attribute_names: *mut *const gchar, attribute_values: *mut *const gchar, error: *mut *mut GError, first_type: GMarkupCollectType, first_attr: *const gchar, ...) -> gboolean;
    pub fn g_markup_error_quark() -> GQuark;
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
    pub fn g_markup_parse_context_end_parse(context: *mut GMarkupParseContext) -> gboolean;
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
    pub fn g_markup_parse_context_get_element_stack(context: *mut GMarkupParseContext) -> *const GSList;
    pub fn g_markup_parse_context_get_position(context: *mut GMarkupParseContext, line_number: gint, char_number: gint);
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_new(parser: *const GMarkupParser, flags: GMarkupParseFlags, user_data: gpointer, user_data_dnotify: GDestroyNotify) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_parse(context: *mut GMarkupParseContext, text: *const gchar, text_len: gssize) -> gboolean;
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_push(context: *mut GMarkupParseContext, parser: *const GMarkupParser, user_data: gpointer);
    pub fn g_markup_parse_context_ref(context: *mut GMarkupParseContext) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
    pub fn g_markup_printf_escaped(format: *const gchar, ...) -> *mut gchar;
    pub fn g_match_info_expand_references(match_info: *const GMatchInfo, string_to_expand: *const gchar) -> *mut gchar;
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
    pub fn g_match_info_fetch_named(match_info: *const GMatchInfo, name: *const gchar) -> *mut gchar;
    pub fn g_match_info_fetch_named_pos(match_info: *const GMatchInfo, name: *const gchar, start_pos: gint, end_pos: gint) -> gboolean;
    pub fn g_match_info_fetch_pos(match_info: *const GMatchInfo, match_num: gint, start_pos: gint, end_pos: gint) -> gboolean;
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_next(match_info: *mut GMatchInfo) -> gboolean;
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
    pub fn g_mem_is_system_malloc() -> gboolean;
    pub fn g_mem_profile();
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
    pub fn g_mutex_clear(mutex: *mut GMutex);
    pub fn g_mutex_init(mutex: *mut GMutex);
    pub fn g_mutex_lock(mutex: *mut GMutex);
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
    pub fn g_mutex_unlock(mutex: *mut GMutex);
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
    pub fn g_node_children_foreach(node: *mut GNode, flags: GTraverseFlags, func: GNodeForeachFunc, data: gpointer);
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
    pub fn g_node_depth(node: *mut GNode) -> guint;
    pub fn g_node_destroy(root: *mut GNode);
    pub fn g_node_find(root: *mut GNode, order: GTraverseType, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_after(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_before(parent: *mut GNode, sibling: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_max_height(root: *mut GNode) -> guint;
    pub fn g_node_n_children(node: *mut GNode) -> guint;
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
    pub fn g_node_new(data: gpointer) -> *mut GNode;
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_reverse_children(node: *mut GNode);
    pub fn g_node_traverse(root: *mut GNode, order: GTraverseType, flags: GTraverseFlags, max_depth: gint, func: GNodeTraverseFunc, data: gpointer);
    pub fn g_node_unlink(node: *mut GNode);
    pub fn g_nullify_pointer(nullify_location: gpointer);
    pub fn g_on_error_query(prg_name: *const gchar);
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
    pub fn g_once_init_enter(location: gpointer) -> gboolean;
    pub fn g_once_init_leave(location: gpointer, result: gsize);
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_add_main_entries(context: *mut GOptionContext, entries: *const GOptionEntry, translation_domain: *const gchar);
    pub fn g_option_context_free(context: *mut GOptionContext);
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
    pub fn g_option_context_get_help(context: *mut GOptionContext, main_help: gboolean, group: *mut GOptionGroup) -> *mut gchar;
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
    pub fn g_option_context_parse(context: *mut GOptionContext, argc: gint, argv: *mut *mut gchar) -> gboolean;
    pub fn g_option_context_parse_strv(context: *mut GOptionContext, arguments: *mut *mut gchar) -> gboolean;
    pub fn g_option_context_set_description(context: *mut GOptionContext, description: *const gchar);
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
    pub fn g_option_context_set_ignore_unknown_options(context: *mut GOptionContext, ignore_unknown: gboolean);
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
    pub fn g_option_context_set_translate_func(context: *mut GOptionContext, func: Option<GTranslateFunc>, data: gpointer, destroy_notify: Option<GDestroyNotify>);
    pub fn g_option_context_set_translation_domain(context: *mut GOptionContext, domain: *const gchar);
    pub fn g_option_error_quark() -> GQuark;
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
    pub fn g_option_group_free(group: *mut GOptionGroup);
    pub fn g_option_group_new(name: *const gchar, description: *const gchar, help_description: *const gchar, user_data: gpointer, destroy: Option<GDestroyNotify>) -> *mut GOptionGroup;
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
    pub fn g_option_group_set_parse_hooks(group: *mut GOptionGroup, pre_parse_func: Option<GOptionParseFunc>, post_parse_func: Option<GOptionParseFunc>);
    pub fn g_option_group_set_translate_func(group: *mut GOptionGroup, func: Option<GTranslateFunc>, data: gpointer, destroy_notify: Option<GDestroyNotify>);
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
    pub fn g_option_group_unref(group: *mut GOptionGroup);
    pub fn g_parse_debug_string(string: *const gchar, keys: *mut GDebugKey, nkeys: guint) -> guint;
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
    pub fn g_pattern_match(pspec: *mut GPatternSpec, string_length: guint, string: *const gchar, string_reversed: *const gchar) -> gboolean;
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
    pub fn g_pointer_bit_lock(address: gpointer, lock_bit: gint);
    pub fn g_pointer_bit_trylock(address: gpointer, lock_bit: gint) -> gboolean;
    pub fn g_pointer_bit_unlock(address: gpointer, lock_bit: gint);
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
    pub fn g_print(format: *const gchar, ...);
    pub fn g_printerr(format: *const gchar, ...);
    pub fn g_printf(format: *mut gchar, ...) -> gint;
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
    pub fn g_propagate_error(dest: *mut GError, src: *mut GError);
    pub fn g_propagate_prefixed_error(dest: *mut *mut GError, src: *mut GError, format: *const gchar, ...);
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> gpointer;
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
    pub fn g_ptr_array_new() -> *mut GPtrArray;
    pub fn g_ptr_array_new_full(reserved_size: guint, element_free_func: Option<GDestroyNotify>) -> *mut GPtrArray;
    pub fn g_ptr_array_new_with_free_func(element_free_func: Option<GDestroyNotify>) -> *mut GPtrArray;
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
    pub fn g_ptr_array_remove_range(array: *mut GPtrArray, index_: guint, length: guint) -> *mut GPtrArray;
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: Option<GDestroyNotify>);
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
    pub fn g_ptr_array_sort_with_data(array: *mut GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
    pub fn g_qsort_with_data(pbase: gconstpointer, total_elems: gint, size: gsize, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
    pub fn g_queue_clear(queue: *mut GQueue);
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
    pub fn g_queue_find_custom(queue: *mut GQueue, data: gconstpointer, func: GCompareFunc) -> *mut GList;
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
    pub fn g_queue_free(queue: *mut GQueue);
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
    pub fn g_queue_init(queue: *mut GQueue);
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_sorted(queue: *mut GQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
    pub fn g_queue_new() -> *mut GQueue;
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
    pub fn g_queue_reverse(queue: *mut GQueue);
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
    pub fn g_rand_free(rand_: *mut GRand);
    pub fn g_rand_int(rand_: *mut GRand) -> u32;
    pub fn g_rand_int_range(rand_: *mut GRand, begin: i32, end: i32) -> i32;
    pub fn g_rand_new() -> *mut GRand;
    pub fn g_rand_new_with_seed(seed: u32) -> *mut GRand;
    pub fn g_rand_new_with_seed_array(seed: u32, seed_length: guint) -> *mut GRand;
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: u32);
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: u32, seed_length: guint);
    pub fn g_random_double() -> gdouble;
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
    pub fn g_random_int() -> u32;
    pub fn g_random_int_range(begin: i32, end: i32) -> i32;
    pub fn g_random_set_seed(seed: u32);
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
    pub fn g_regex_check_replacement(replacement: *const gchar, has_references: gboolean) -> gboolean;
    pub fn g_regex_error_quark() -> GQuark;
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
    pub fn g_regex_escape_string(string: *mut gchar, length: gint) -> *mut gchar;
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
    pub fn g_regex_match(regex: *const GRegex, string: *const gchar, match_options: GRegexMatchFlags, match_info: *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all(regex: *const GRegex, string: *const gchar, match_options: GRegexMatchFlags, match_info: *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all_full(regex: *const GRegex, string: *mut gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_full(regex: *const GRegex, string: *mut gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_simple(pattern: *const gchar, string: *const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) -> gboolean;
    pub fn g_regex_new(pattern: *const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) -> *mut GRegex;
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
    pub fn g_regex_replace(regex: *const GRegex, string: *mut gchar, string_len: gssize, start_position: gint, replacement: *const gchar, match_options: GRegexMatchFlags) -> *mut gchar;
    pub fn g_regex_replace_eval(regex: *const GRegex, string: *mut gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, eval: GRegexEvalCallback, user_data: gpointer) -> *mut gchar;
    pub fn g_regex_replace_literal(regex: *const GRegex, string: *mut gchar, string_len: gssize, start_position: gint, replacement: *const gchar, match_options: GRegexMatchFlags) -> *mut gchar;
    pub fn g_regex_split(regex: *const GRegex, string: *const gchar, match_options: GRegexMatchFlags) -> *mut *mut gchar;
    pub fn g_regex_split_full(regex: *const GRegex, string: *mut gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, max_tokens: gint) -> *mut *mut gchar;
    pub fn g_regex_split_simple(pattern: *const gchar, string: *const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) -> *mut *mut gchar;
    pub fn g_regex_unref(regex: *mut GRegex);
    pub fn g_reload_user_special_dirs_cache();
    pub fn g_return_if_fail_warning(log_domain: *const gchar, pretty_function: *const gchar, expression: *const gchar);
    pub fn g_rmdir(filename: *const gchar) -> gint;
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
    pub fn g_scanner_destroy(scanner: *mut GScanner);
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_scope_add_symbol(scanner: *mut GScanner, scope_id: guint, symbol: *const gchar, value: gpointer);
    pub fn g_scanner_scope_foreach_symbol(scanner: *mut GScanner, scope_id: guint, func: GHFunc, user_data: gpointer);
    pub fn g_scanner_scope_lookup_symbol(scanner: *mut GScanner, scope_id: guint, symbol: *const gchar) -> gpointer;
    pub fn g_scanner_scope_remove_symbol(scanner: *mut GScanner, scope_id: guint, symbol: *const gchar);
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
    pub fn g_scanner_unexp_token(scanner: *mut GScanner, expected_token: GTokenType, identifier_spec: *const gchar, symbol_spec: *const gchar, symbol_name: *const gchar, message: *const gchar, is_error: gint);
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
    pub fn g_sequence_foreach_range(begin: *mut GSequenceIter, end: *mut GSequenceIter, func: GFunc, user_data: gpointer);
    pub fn g_sequence_free(seq: *mut GSequence);
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_lookup(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_lookup_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
    pub fn g_sequence_move_range(dest: *mut GSequenceIter, begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_new(data_destroy: Option<GDestroyNotify>) -> *mut GSequence;
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_range_get_midpoint(begin: *mut GSequenceIter, end: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_search(seq: *mut GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_search_iter(seq: *mut GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_changed(iter: *mut GSequenceIter, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_changed_iter(iter: *mut GSequenceIter, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_iter(seq: *mut GSequence, cmp_func: GSequenceIterCompareFunc, cmp_data: gpointer);
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
    pub fn g_set_application_name(application_name: *const gchar);
    pub fn g_set_error(err: *mut *mut GError, domain: GQuark, code: gint, format: *const gchar, ...);
    pub fn g_set_error_literal(err: *mut *mut GError, domain: GQuark, code: gint, message: *const gchar);
    pub fn g_set_prgname(prgname: *const gchar);
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
    pub fn g_shell_error_quark() -> GQuark;
    pub fn g_shell_parse_argv(command_line: *const gchar, argcp: gint, argvp: *mut *mut gchar) -> gboolean;
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
    pub fn g_shell_unquote(quoted_string: *const gchar) -> *mut gchar;
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
    pub fn g_slice_free_chain_with_offset(block_size: gsize, mem_chain: gpointer, next_offset: gsize);
    pub fn g_slice_get_config(ckey: GSliceConfig) -> i64;
    pub fn g_slice_get_config_state(ckey: GSliceConfig, address: i64, n_values: guint) -> i64;
    pub fn g_slice_set_config(ckey: GSliceConfig, value: i64);
    pub fn g_slist_alloc() -> *mut GSList;
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy_deep(list: *mut GSList, func: GCopyFunc, user_data: gpointer) -> *mut GSList;
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_find_custom(list: *mut GSList, data: gconstpointer, func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
    pub fn g_slist_free(list: *mut GSList);
    pub fn g_slist_free_1(list: *mut GSList);
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
    pub fn g_slist_insert_before(slist: *mut GSList, sibling: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_insert_sorted(list: *mut GSList, data: gpointer, func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_insert_sorted_with_data(list: *mut GSList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_length(list: *mut GSList) -> guint;
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_sort_with_data(list: *mut GSList, compare_func: GCompareDataFunc, user_data: gpointer) -> *mut GSList;
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *mut gchar, ...) -> gint;
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
    pub fn g_source_destroy(source: *mut GSource);
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
    pub fn g_source_get_id(source: *mut GSource) -> guint;
    pub fn g_source_get_name(source: *mut GSource) -> *const gchar;
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
    pub fn g_source_get_ready_time(source: *mut GSource) -> i64;
    pub fn g_source_get_time(source: *mut GSource) -> i64;
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
    pub fn g_source_remove(tag: guint) -> gboolean;
    pub fn g_source_remove_by_funcs_user_data(funcs: *mut GSourceFuncs, user_data: gpointer) -> gboolean;
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_set_callback(source: *mut GSource, func: GSourceFunc, data: gpointer, notify: Option<GDestroyNotify>);
    pub fn g_source_set_callback_indirect(source: *mut GSource, callback_data: gpointer, callback_funcs: *mut GSourceCallbackFuncs);
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
    pub fn g_source_set_name(source: *mut GSource, name: *const gchar);
    pub fn g_source_set_name_by_id(tag: guint, name: *const gchar);
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: i64);
    pub fn g_source_unref(source: *mut GSource);
    pub fn g_spaced_primes_closest(num: guint) -> guint;
    pub fn g_spawn_async(working_directory: *const gchar, argv: *mut *mut gchar, envp: *mut *mut gchar, flags: GSpawnFlags, child_setup: Option<GSpawnChildSetupFunc>, user_data: gpointer, child_pid: GPid) -> gboolean;
    pub fn g_spawn_async_with_pipes(working_directory: *const gchar, argv: *mut *mut gchar, envp: *mut *mut gchar, flags: GSpawnFlags, child_setup: Option<GSpawnChildSetupFunc>, user_data: gpointer, child_pid: GPid, standard_input: gint, standard_output: gint, standard_error: gint) -> gboolean;
    pub fn g_spawn_check_exit_status(exit_status: gint) -> gboolean;
    pub fn g_spawn_close_pid(pid: GPid);
    pub fn g_spawn_command_line_async(command_line: *const gchar) -> gboolean;
    pub fn g_spawn_command_line_sync(command_line: *const gchar, standard_output: *mut gchar, standard_error: *mut gchar, exit_status: gint) -> gboolean;
    pub fn g_spawn_error_quark() -> GQuark;
    pub fn g_spawn_exit_error_quark() -> GQuark;
    pub fn g_spawn_sync(working_directory: *const gchar, argv: *mut *mut gchar, envp: *mut *mut gchar, flags: GSpawnFlags, child_setup: Option<GSpawnChildSetupFunc>, user_data: gpointer, standard_output: *mut gchar, standard_error: *mut gchar, exit_status: gint) -> gboolean;
    pub fn g_sprintf(string: *mut gchar, format: *mut gchar, ...) -> gint;
    pub fn g_stpcpy(dest: *mut gchar, src: *const gchar) -> *mut gchar;
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_str_has_prefix(str: *const gchar, prefix: *const gchar) -> gboolean;
    pub fn g_str_has_suffix(str: *const gchar, suffix: *const gchar) -> gboolean;
    pub fn g_str_hash(v: gconstpointer) -> guint;
    pub fn g_str_is_ascii(str: *const gchar) -> gboolean;
    pub fn g_str_match_string(search_term: *const gchar, potential_hit: *const gchar, accept_alternates: gboolean) -> gboolean;
    pub fn g_str_to_ascii(str: *const gchar, from_locale: *const gchar) -> *mut gchar;
    pub fn g_str_tokenize_and_fold(string: *const gchar, translit_locale: *const gchar, ascii_alternates: *mut *mut gchar) -> *mut *mut gchar;
    pub fn g_strcanon(string: *mut gchar, valid_chars: *const gchar, substitutor: gchar) -> *mut gchar;
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
    pub fn g_strcmp0(str1: *const gchar, str2: *const gchar) -> gint;
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
    pub fn g_strdelimit(string: *mut gchar, delimiters: *const gchar, new_delimiter: gchar) -> *mut gchar;
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
    pub fn g_strdup(str: *const gchar) -> *mut gchar;
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
    pub fn g_strerror(errnum: gint) -> *const gchar;
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
    pub fn g_strfreev(str_array: *mut *mut gchar);
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_append_len(string: *mut GString, val: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
    pub fn g_string_append_uri_escaped(string: *mut GString, unescaped: *const gchar, reserved_chars_allowed: *const gchar, allow_utf8: gboolean) -> *mut GString;
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
    pub fn g_string_chunk_insert_const(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
    pub fn g_string_chunk_insert_len(chunk: *mut GStringChunk, string: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
    pub fn g_string_down(string: *mut GString) -> *mut GString;
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
    pub fn g_string_hash(str: *const GString) -> guint;
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
    pub fn g_string_insert_len(string: *mut GString, pos: gssize, val: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar) -> *mut GString;
    pub fn g_string_new(init: *const gchar) -> *mut GString;
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
    pub fn g_string_overwrite_len(string: *mut GString, pos: gsize, val: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_prepend_len(string: *mut GString, val: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
    pub fn g_string_up(string: *mut GString) -> *mut GString;
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
    pub fn g_strndup(str: *const gchar, n: gsize) -> *mut gchar;
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
    pub fn g_strrstr_len(haystack: *const gchar, haystack_len: gssize, needle: *const gchar) -> *mut gchar;
    pub fn g_strsignal(signum: gint) -> *const gchar;
    pub fn g_strsplit(string: *const gchar, delimiter: *const gchar, max_tokens: gint) -> *mut *mut gchar;
    pub fn g_strsplit_set(string: *const gchar, delimiters: *const gchar, max_tokens: gint) -> *mut *mut gchar;
    pub fn g_strstr_len(haystack: *const gchar, haystack_len: gssize, needle: *const gchar) -> *mut gchar;
    pub fn g_strtod(nptr: *const gchar, endptr: *mut gchar) -> gdouble;
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
    pub fn g_strv_contains(strv: *const *const gchar, str: *const gchar) -> gboolean;
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
    pub fn g_test_add_data_func(testpath: *const gchar, test_data: gconstpointer, test_func: GTestDataFunc);
    pub fn g_test_add_data_func_full(testpath: *const gchar, test_data: gpointer, test_func: GTestDataFunc, data_free_func: GDestroyNotify);
    pub fn g_test_add_func(testpath: *const gchar, test_func: GTestFunc);
    pub fn g_test_add_vtable(testpath: *const gchar, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc);
    pub fn g_test_assert_expected_messages_internal(domain: *const gchar, file: *const gchar, line: gint, func: *const gchar);
    pub fn g_test_bug(bug_uri_snippet: *const gchar);
    pub fn g_test_bug_base(uri_pattern: *const gchar);
    pub fn g_test_build_filename(file_type: GTestFileType, first_path: *const gchar, ...) -> *mut gchar;
    pub fn g_test_create_case(test_name: *const gchar, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) -> *mut GTestCase;
    pub fn g_test_create_suite(suite_name: *const gchar) -> *mut GTestSuite;
    pub fn g_test_expect_message(log_domain: *const gchar, log_level: GLogLevelFlags, pattern: *const gchar);
    pub fn g_test_fail();
    pub fn g_test_failed() -> gboolean;
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
    pub fn g_test_get_filename(file_type: GTestFileType, first_path: *const gchar, ...) -> *const gchar;
    pub fn g_test_get_root() -> *mut GTestSuite;
    pub fn g_test_incomplete(msg: *const gchar);
    pub fn g_test_init(argc: gint, argv: *mut gchar, ...);
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
    pub fn g_test_log_buffer_push(tbuffer: *mut GTestLogBuffer, n_bytes: guint, bytes: u8);
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const gchar;
    pub fn g_test_maximized_result(maximized_quantity: gdouble, format: *const gchar, ...);
    pub fn g_test_message(format: *const gchar, ...);
    pub fn g_test_minimized_result(minimized_quantity: gdouble, format: *const gchar, ...);
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
    pub fn g_test_queue_free(gfree_pointer: gpointer);
    pub fn g_test_rand_double() -> gdouble;
    pub fn g_test_rand_double_range(range_start: gdouble, range_end: gdouble) -> gdouble;
    pub fn g_test_rand_int() -> i32;
    pub fn g_test_rand_int_range(begin: i32, end: i32) -> i32;
    pub fn g_test_run() -> gint;
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> gint;
    pub fn g_test_set_nonfatal_assertions();
    pub fn g_test_skip(msg: *const gchar);
    pub fn g_test_subprocess() -> gboolean;
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
    pub fn g_test_timer_elapsed() -> gdouble;
    pub fn g_test_timer_last() -> gdouble;
    pub fn g_test_timer_start();
    pub fn g_test_trap_assertions(domain: *const gchar, file: *const gchar, line: gint, func: *const gchar, assertion_flags: u64, pattern: *const gchar);
    pub fn g_test_trap_fork(usec_timeout: u64, test_trap_flags: GTestTrapFlags) -> gboolean;
    pub fn g_test_trap_has_passed() -> gboolean;
    pub fn g_test_trap_reached_timeout() -> gboolean;
    pub fn g_test_trap_subprocess(test_path: *const gchar, usec_timeout: u64, test_flags: GTestSubprocessFlags);
    pub fn g_thread_error_quark() -> GQuark;
    pub fn g_thread_exit(retval: gpointer);
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
    pub fn g_thread_pool_get_max_idle_time() -> guint;
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
    pub fn g_thread_pool_new(func: GFunc, user_data: gpointer, max_threads: gint, exclusive: gboolean) -> *mut GThreadPool;
    pub fn g_thread_pool_push(pool: *mut GThreadPool, data: gpointer) -> gboolean;
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
    pub fn g_thread_pool_set_max_threads(pool: *mut GThreadPool, max_threads: gint) -> gboolean;
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
    pub fn g_thread_pool_set_sort_function(pool: *mut GThreadPool, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_thread_pool_stop_unused_threads();
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
    pub fn g_thread_self() -> *mut GThread;
    pub fn g_thread_try_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
    pub fn g_thread_unref(thread: *mut GThread);
    pub fn g_thread_yield();
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
    pub fn g_time_zone_adjust_time(tz: *mut GTimeZone, type_: GTimeType, time_: i64) -> gint;
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: i64) -> gint;
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> i32;
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_timeout_add_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: Option<GDestroyNotify>) -> guint;
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_timeout_add_seconds_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: Option<GDestroyNotify>) -> guint;
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
    pub fn g_timer_continue(timer: *mut GTimer);
    pub fn g_timer_destroy(timer: *mut GTimer);
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: gulong) -> gdouble;
    pub fn g_timer_new() -> *mut GTimer;
    pub fn g_timer_reset(timer: *mut GTimer);
    pub fn g_timer_start(timer: *mut GTimer);
    pub fn g_timer_stop(timer: *mut GTimer);
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
    pub fn g_tree_destroy(tree: *mut GTree);
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
    pub fn g_tree_height(tree: *mut GTree) -> gint;
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
    pub fn g_tree_lookup_extended(tree: *mut GTree, lookup_key: gconstpointer, orig_key: gpointer, value: gpointer) -> gboolean;
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
    pub fn g_tree_new_full(key_compare_func: GCompareDataFunc, key_compare_data: gpointer, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) -> *mut GTree;
    pub fn g_tree_new_with_data(key_compare_func: GCompareDataFunc, key_compare_data: gpointer) -> *mut GTree;
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_search(tree: *mut GTree, search_func: GCompareFunc, user_data: gconstpointer) -> gpointer;
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_traverse(tree: *mut GTree, traverse_func: GTraverseFunc, traverse_type: GTraverseType, user_data: gpointer);
    pub fn g_tree_unref(tree: *mut GTree);
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_ucs4_to_utf16(str: gunichar, len: glong, items_read: glong, items_written: glong) -> u16;
    pub fn g_ucs4_to_utf8(str: gunichar, len: glong, items_read: glong, items_written: glong) -> *mut gchar;
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: gunichar) -> gboolean;
    pub fn g_unichar_decompose(ch: gunichar, a: gunichar, b: gunichar) -> gboolean;
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
    pub fn g_unichar_fully_decompose(ch: gunichar, compat: gboolean, result: gunichar, result_len: gsize) -> gsize;
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: gunichar) -> gboolean;
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: gsize) -> gunichar;
    pub fn g_unicode_canonical_ordering(string: gunichar, len: gsize);
    pub fn g_unicode_script_from_iso15924(iso15924: u32) -> GUnicodeScript;
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> u32;
    pub fn g_unlink(filename: *const gchar) -> gint;
    pub fn g_unsetenv(variable: *const gchar);
    pub fn g_uri_escape_string(unescaped: *const gchar, reserved_chars_allowed: *const gchar, allow_utf8: gboolean) -> *mut gchar;
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
    pub fn g_uri_parse_scheme(uri: *const gchar) -> *mut gchar;
    pub fn g_uri_unescape_segment(escaped_string: *const gchar, escaped_string_end: *const gchar, illegal_characters: *const gchar) -> *mut gchar;
    pub fn g_uri_unescape_string(escaped_string: *const gchar, illegal_characters: *const gchar) -> *mut gchar;
    pub fn g_usleep(microseconds: gulong);
    pub fn g_utf16_to_ucs4(str: u16, len: glong, items_read: glong, items_written: glong) -> gunichar;
    pub fn g_utf16_to_utf8(str: u16, len: glong, items_read: glong, items_written: glong) -> *mut gchar;
    pub fn g_utf8_casefold(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
    pub fn g_utf8_collate_key(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_collate_key_for_filename(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
    pub fn g_utf8_find_prev_char(str: *const gchar, p: *const gchar) -> *mut gchar;
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
    pub fn g_utf8_normalize(str: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
    pub fn g_utf8_offset_to_pointer(str: *const gchar, offset: glong) -> *mut gchar;
    pub fn g_utf8_pointer_to_offset(str: *const gchar, pos: *const gchar) -> glong;
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
    pub fn g_utf8_strdown(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
    pub fn g_utf8_strreverse(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_strup(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_substring(str: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
    pub fn g_utf8_to_ucs4(str: *const gchar, len: glong, items_read: glong, items_written: glong) -> gunichar;
    pub fn g_utf8_to_ucs4_fast(str: *const gchar, len: glong, items_written: glong) -> gunichar;
    pub fn g_utf8_to_utf16(str: *const gchar, len: glong, items_read: glong, items_written: glong) -> u16;
    pub fn g_utf8_validate(str: *mut gchar, max_len: gssize, end: *const gchar) -> gboolean;
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_check_format_string(value: *mut GVariant, format_string: *const gchar, copy_only: gboolean) -> gboolean;
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
    pub fn g_variant_dict_insert(dict: *mut GVariantDict, key: *const gchar, format_string: *const gchar, ...);
    pub fn g_variant_dict_insert_value(dict: *mut GVariantDict, key: *const gchar, value: *mut GVariant);
    pub fn g_variant_dict_lookup(dict: *mut GVariantDict, key: *const gchar, format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_dict_lookup_value(dict: *mut GVariantDict, key: *const gchar, expected_type: *const GVariantType) -> *mut GVariant;
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: gsize) -> *mut gchar;
    pub fn g_variant_dup_bytestring_array(value: *mut GVariant, length: gsize) -> *mut *mut gchar;
    pub fn g_variant_dup_objv(value: *mut GVariant, length: gsize) -> *mut *mut gchar;
    pub fn g_variant_dup_string(value: *mut GVariant, length: gsize) -> *mut gchar;
    pub fn g_variant_dup_strv(value: *mut GVariant, length: gsize) -> *mut *mut gchar;
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
    pub fn g_variant_get_byte(value: *mut GVariant) -> u8;
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *mut gchar;
    pub fn g_variant_get_bytestring_array(value: *mut GVariant, length: gsize) -> *mut *mut gchar;
    pub fn g_variant_get_child(value: *mut GVariant, index_: gsize, format_string: *const gchar, ...);
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
    pub fn g_variant_get_fixed_array(value: *mut GVariant, n_elements: gsize, element_size: gsize) -> gconstpointer;
    pub fn g_variant_get_handle(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int16(value: *mut GVariant) -> i16;
    pub fn g_variant_get_int32(value: *mut GVariant) -> i32;
    pub fn g_variant_get_int64(value: *mut GVariant) -> i64;
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_objv(value: *mut GVariant, length: gsize) -> *mut *mut gchar;
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
    pub fn g_variant_get_string(value: *mut GVariant, length: gsize) -> *const gchar;
    pub fn g_variant_get_strv(value: *mut GVariant, length: gsize) -> *mut *mut gchar;
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
    pub fn g_variant_get_uint16(value: *mut GVariant) -> u16;
    pub fn g_variant_get_uint32(value: *mut GVariant) -> u32;
    pub fn g_variant_get_uint64(value: *mut GVariant) -> u64;
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_hash(value: gconstpointer) -> guint;
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
    pub fn g_variant_iter_loop(iter: *mut GVariantIter, format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
    pub fn g_variant_iter_next(iter: *mut GVariantIter, format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
    pub fn g_variant_lookup(dictionary: *mut GVariant, key: *const gchar, format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_lookup_value(dictionary: *mut GVariant, key: *const gchar, expected_type: *const GVariantType) -> *mut GVariant;
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_new_array(child_type: *const GVariantType, children: *mut *mut GVariant, n_children: gsize) -> *mut GVariant;
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
    pub fn g_variant_new_byte(value: u8) -> *mut GVariant;
    pub fn g_variant_new_bytestring(string: *mut gchar) -> *mut GVariant;
    pub fn g_variant_new_bytestring_array(strv: *mut *mut gchar, length: gssize) -> *mut GVariant;
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
    pub fn g_variant_new_fixed_array(element_type: *const GVariantType, elements: gconstpointer, n_elements: gsize, element_size: gsize) -> *mut GVariant;
    pub fn g_variant_new_from_bytes(type_: *const GVariantType, bytes: *mut GBytes, trusted: gboolean) -> *mut GVariant;
    pub fn g_variant_new_from_data(type_: *const GVariantType, data: gconstpointer, size: gsize, trusted: gboolean, notify: GDestroyNotify, user_data: gpointer) -> *mut GVariant;
    pub fn g_variant_new_handle(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int16(value: i16) -> *mut GVariant;
    pub fn g_variant_new_int32(value: i32) -> *mut GVariant;
    pub fn g_variant_new_int64(value: i64) -> *mut GVariant;
    pub fn g_variant_new_maybe(child_type: *const GVariantType, child: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_objv(strv: *mut *mut gchar, length: gssize) -> *mut GVariant;
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_strv(strv: *mut *mut gchar, length: gssize) -> *mut GVariant;
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
    pub fn g_variant_new_tuple(children: *mut *mut GVariant, n_children: gsize) -> *mut GVariant;
    pub fn g_variant_new_uint16(value: u16) -> *mut GVariant;
    pub fn g_variant_new_uint32(value: u32) -> *mut GVariant;
    pub fn g_variant_new_uint64(value: u64) -> *mut GVariant;
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_parse(type_: *const GVariantType, text: *const gchar, limit: *const gchar, endptr: *mut *const gchar) -> *mut GVariant;
    pub fn g_variant_parse_error_print_context(error: *mut GError, source_str: *const gchar) -> *mut gchar;
    pub fn g_variant_parse_error_quark() -> GQuark;
    pub fn g_variant_parser_get_error_quark() -> GQuark;
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
    pub fn g_variant_print_string(value: *mut GVariant, string: *mut GString, type_annotate: gboolean) -> *mut GString;
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_type_checked_(arg0: *const gchar) -> *const GVariantType;
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_free(type_: *mut GVariantType);
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_subtype_of(type_: *const GVariantType, supertype: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_dict_entry(key: *const GVariantType, value: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_tuple(items: *mut *mut GVariantType, length: gint) -> *mut GVariantType;
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
    pub fn g_variant_type_string_scan(string: *const gchar, limit: *const gchar, endptr: *const gchar) -> gboolean;
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_unref(value: *mut GVariant);
    pub fn g_warn_message(domain: *const gchar, file: *const gchar, line: gint, func: *const gchar, warnexpr: *const gchar);
    pub fn glib_check_version(required_major: guint, required_minor: guint, required_micro: guint) -> *const gchar;
}

#[cfg(unix)]
pub mod unix {
    use gtypes::*;
    use super::*;

    extern {
        pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
        pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
        pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
        pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
        pub fn g_unix_error_quark() -> GQuark;
        pub fn g_unix_fd_add(fd: gint, condition: GIOCondition, function: GUnixFDSourceFunc, user_data: gpointer) -> guint;
        pub fn g_unix_fd_add_full(priority: gint, fd: gint, condition: GIOCondition, function: GUnixFDSourceFunc, user_data: gpointer, notify: GDestroyNotify) -> guint;
        pub fn g_unix_fd_source_new(fd: gint, condition: GIOCondition) -> *mut GSource;
        pub fn g_unix_open_pipe(fds: gint, flags: gint) -> gboolean;
        pub fn g_unix_set_fd_nonblocking(fd: gint, nonblock: gboolean) -> gboolean;
        pub fn g_unix_signal_add(signum: gint, handler: GSourceFunc, user_data: gpointer) -> guint;
        pub fn g_unix_signal_add_full(priority: gint, signum: gint, handler: GSourceFunc, user_data: gpointer, notify: GDestroyNotify) -> guint;
        pub fn g_unix_signal_source_new(signum: gint) -> *mut GSource;
    }
}

#[cfg(unix)]
pub use unix::*;
