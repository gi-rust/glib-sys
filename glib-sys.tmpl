<%!

from grust.namematch import MatchList

# The GType symbols are in libgobject
ignore_gtype_functions = True

suppress_c_names = MatchList(
    # Structures containing bit fields, custom-defined below
    "GDate",
    "GHookList",
    "GIOChannel",
    "GScannerConfig",

    # Unions, custom-defined below
    "GDoubleIEEE754",
    "GFloatIEEE754",
    "GMutex",
    "GTokenValue",

    # C compiler/ABI feature macros, varying with target
    "G_HAVE_*",

    # System-specific definitions, custom-defined below
    "GLIB_SYSDEF_*",
    "GIOCondition",

    # Has a long double parameter
    "g_assertion_message_cmpnum"
)

%>\
<%inherit file="/sys/crate.tmpl"/>

<%block name="custom_crate_attributes">\
#![allow(non_upper_case_globals)]  // For G_CSET_a_2_z
</%block>

<%block name="custom_types">\

#[repr(C)]
pub struct GDate([u32; 2]);

#[repr(C)]
pub struct GDoubleIEEE754(gdouble);

#[repr(C)]
pub struct GFloatIEEE754(gfloat);

#[repr(C)]
pub struct GHookList {
    pub seq_id: gulong,
    // Two bit fields in the C definition here
    _hook_size_is_setup: u32,
    pub hooks: *mut GHook,
    dummy3: gpointer,
    pub finalize_hook: Option<GHookFinalizeFunc>,
    dummy: [gpointer; 2]
}

#[repr(C)]
pub struct GIOChannel {
    ref_count :gint,
    funcs: *mut GIOFuncs,

    encoding: *mut gchar,
    read_cd: GIConv,
    write_cd: GIConv,
    line_term: *mut gchar,
    line_term_len: gint,

    buf_size: gsize,
    read_buf: *mut GString,
    encoded_read_buf: *mut GString,
    write_buf: *mut GString,

    ## 11 * size_of(usize) at this point

    partial_write_buf: [gchar; 6],

    // A group of bit fields in the C definition here
    // to fit after partial_write_buf
    flags: u16,

    reserved1: gpointer,
    reserved2: gpointer
}

// This happens to get the same determinants in all Unixes I have surveyed,
// and for non-Unix GLib provides the same values.
#[repr(C)]
pub enum GIOCondition {
    In   =  1,
    Out  =  4,
    Pri  =  2,
    Err  =  8,
    Hup  = 16,
    Nval = 32
}
pub const G_IO_IN:   guint = GIOCondition::In as guint;
pub const G_IO_OUT:  guint = GIOCondition::Out as guint;
pub const G_IO_PRI:  guint = GIOCondition::Pri as guint;
pub const G_IO_ERR:  guint = GIOCondition::Err as guint;
pub const G_IO_HUP:  guint = GIOCondition::Hup as guint;
pub const G_IO_NVAL: guint = GIOCondition::Nval as guint;

#[cfg(target_pointer_width = "32")]
#[repr(C)]
pub struct GMutex([guint; 2]);

// NOTE: An ILP64 target would need GMutex defined as above
#[cfg(target_pointer_width = "64")]
#[repr(C)]
pub struct GMutex(gpointer);

#[repr(C)]
pub struct  GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,

    // a group of bit fields in the C definition here
    flags: u32,

    padding_dummy: guint
}

#[repr(C)]
pub struct GTokenValue {
    v: u64
}

</%block>

<%block name="custom_constants">\

pub const GLIB_SYSDEF_AF_INET:  gint = libc::AF_INET;
pub const GLIB_SYSDEF_AF_INET6: gint = libc::AF_INET6;
pub const GLIB_SYSDEF_AF_UNIX:  gint = libc::AF_UNIX;

mod consts {

    // The BSD definitions are used everywhere,
    // but we should keep an exhaustive list, just in case.
    #[cfg(any(target_os = "linux",
              target_os = "windows",
              target_os = "macos",
              target_os = "freebsd",
              target_os = "dragonfly",
              target_os = "openbsd",
              target_os = "bitrig",
              target_os = "netbsd",
              target_os = "android",
              target_os = "nacl"))]
    pub mod os {

        use gtypes::*;

        pub const GLIB_SYSDEF_MSG_OOB:       gint = 1;
        pub const GLIB_SYSDEF_MSG_PEEK:      gint = 2;
        pub const GLIB_SYSDEF_MSG_DONTROUTE: gint = 4;
    }
}

pub use consts::os::*;

</%block>
